{"meta":{"title":"Co2","subtitle":"Co2 の World","description":"","author":"Co2","url":"https://cotocode.github.io","root":"/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"404.html","permalink":"https://cotocode.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2022-07-30T02:51:19.100Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://cotocode.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-07-28T15:13:58.802Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://cotocode.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2022-07-22T16:00:00.000Z","updated":"2022-07-28T15:12:59.744Z","comments":true,"path":"List/index.html","permalink":"https://cotocode.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2022-07-22T16:00:00.000Z","updated":"2022-07-28T15:11:41.577Z","comments":true,"path":"about/index.html","permalink":"https://cotocode.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-07-22T16:00:00.000Z","updated":"2022-07-28T15:11:58.470Z","comments":true,"path":"categories/index.html","permalink":"https://cotocode.github.io/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-07-22T16:00:00.000Z","updated":"2022-07-28T15:11:50.680Z","comments":true,"path":"archives/index.html","permalink":"https://cotocode.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2022-07-23T02:11:28.000Z","updated":"2022-07-28T15:12:07.537Z","comments":true,"path":"census/index.html","permalink":"https://cotocode.github.io/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-07-23T08:42:10.000Z","updated":"2022-07-28T15:12:23.196Z","comments":true,"path":"friends/index.html","permalink":"https://cotocode.github.io/friends/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-07-22T16:00:00.000Z","updated":"2022-07-30T07:51:53.205Z","comments":true,"path":"contact/index.html","permalink":"https://cotocode.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Co2の友链信息 博客名称: Co2の博客 博客网址: https://cotocode.github.io 博客介绍: Stay hungry. Stay foolish"},{"title":"资源分享","date":"2022-07-22T16:00:00.000Z","updated":"2022-07-28T15:13:17.399Z","comments":true,"path":"resource/index.html","permalink":"https://cotocode.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-22T16:00:00.000Z","updated":"2022-07-28T15:13:32.144Z","comments":true,"path":"tags/index.html","permalink":"https://cotocode.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-07-29T14:37:37.813Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/index.html","permalink":"https://cotocode.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/movies/index.html","permalink":"https://cotocode.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/music/index.html","permalink":"https://cotocode.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/tools/index.html","permalink":"https://cotocode.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-07-29T14:37:37.813Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://cotocode.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-07-29T14:37:37.813Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://cotocode.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-07-29T14:37:37.829Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://cotocode.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-07-29T14:37:37.829Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://cotocode.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-07-29T14:37:37.829Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://cotocode.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-07-29T14:37:37.829Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://cotocode.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-07-31T16:12:33.292Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://cotocode.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-07-29T14:37:37.844Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://cotocode.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-07-29T14:37:37.844Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://cotocode.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-07-31T16:12:32.781Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://cotocode.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-07-29T14:37:37.844Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://cotocode.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-07-29T14:37:37.844Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://cotocode.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""}],"posts":[{"title":"二叉树的统一迭代法","slug":"代码随想录/二叉树的统一迭代法","date":"2022-10-07T15:00:00.000Z","updated":"2022-10-07T16:02:07.485Z","comments":true,"path":"posts/148c3546.html","link":"","permalink":"https://cotocode.github.io/posts/148c3546.html","excerpt":"","text":"前序遍历class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） } return result; } }; 中序遍历class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 } } return result; } }; 后序遍历class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 } reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-144. 二叉树的前序遍历","slug":"代码随想录/leetcode-144. 二叉树的前序遍历","date":"2022-10-06T14:00:00.000Z","updated":"2022-10-06T16:56:52.461Z","comments":true,"path":"posts/107bda66.html","link":"","permalink":"https://cotocode.github.io/posts/107bda66.html","excerpt":"","text":"本题地址： leetcode-144. 二叉树的前序遍历 题目描述： 给你二叉树的根节点 root ，返回它节点值的 前序_ _遍历。提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 示例： 输入：root = [1,null,2,3]输出：[1,2,3] 输入：root = []输出：[] 输入：root = [1]输出：[1] 输入：root = [1,2]输出：[1,2] 输入：root = [1,null,2]输出：[1,2] 题解：递归： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void pretravel(TreeNode* node, vector&lt;int&gt; &amp;vec) { if(node == nullptr) return ; vec.push_back(node-&gt;val); pretravel(node-&gt;left,vec); pretravel(node-&gt;right,vec); } vector&lt;int&gt; preorderTraversal(TreeNode* root) { vector&lt;int&gt; res; pretravel(root, res); return res; } }; 非递归： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; preorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; res; if(root == nullptr) return res; st.push(root); while(!st.empty()) { TreeNode *tmp = st.top(); st.pop(); res.push_back(tmp-&gt;val); if(tmp-&gt;right) st.push(tmp-&gt;right); if(tmp-&gt;left) st.push(tmp-&gt;left); } return res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-145. 二叉树的后序遍历","slug":"代码随想录/leetcode-145. 二叉树的后序遍历","date":"2022-10-06T14:00:00.000Z","updated":"2022-10-06T16:56:52.465Z","comments":true,"path":"posts/407b806a.html","link":"","permalink":"https://cotocode.github.io/posts/407b806a.html","excerpt":"","text":"本题地址： leetcode-145. 二叉树的后序遍历 题目描述： 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 **。**提示：树中节点的数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 示例： 输入：root = [1,null,2,3]输出：[3,2,1] 输入：root = []输出：[] 输入：root = [1]输出：[1] 题解：递归： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void posttravel(TreeNode* node, vector&lt;int&gt; &amp;vec) { if(node == nullptr) return ; posttravel(node-&gt;left,vec); posttravel(node-&gt;right,vec); vec.push_back(node-&gt;val); } vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; res; posttravel(root, res); return res; } }; 非递归： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { stack&lt;TreeNode*&gt; st; vector&lt;int&gt; res; if (root == NULL) return res; st.push(root); while (!st.empty()) { TreeNode* node = st.top(); st.pop(); res.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 } reverse(res.begin(), res.end()); // 将结果反转之后就是左右中的顺序了 return res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-94. 二叉树的中序遍历","slug":"代码随想录/leetcode-94. 二叉树的中序遍历","date":"2022-10-06T14:00:00.000Z","updated":"2022-10-06T16:56:52.465Z","comments":true,"path":"posts/b61ab7b0.html","link":"","permalink":"https://cotocode.github.io/posts/b61ab7b0.html","excerpt":"","text":"本题地址： leetcode-94. 二叉树的中序遍历 题目描述： 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。提示：树中节点数目在范围 [0, 100] 内-100 &lt;= Node.val &lt;= 100 示例： 输入：root = [1,null,2,3]输出：[1,3,2] 输入：root = []输出：[] 输入：root = [1]输出：[1] 题解：递归： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: void intravel(TreeNode* node, vector&lt;int&gt; &amp;vec) { if(node == nullptr) return ; intravel(node-&gt;left,vec); vec.push_back(node-&gt;val); intravel(node-&gt;right,vec); } vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; intravel(root, res); return res; } }; 非递归： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int&gt; inorderTraversal(TreeNode* root) { vector&lt;int&gt; res; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 } else { cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); res.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 } } return res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-239. 滑动窗口最大值","slug":"代码随想录/leetcode-239. 滑动窗口最大值","date":"2022-10-05T14:00:00.000Z","updated":"2022-10-05T16:06:42.270Z","comments":true,"path":"posts/6e960a51.html","link":"","permalink":"https://cotocode.github.io/posts/6e960a51.html","excerpt":"","text":"本题地址： leetcode-239. 滑动窗口最大值 题目描述： 给你一个整数数组 nums，有一个大小为&nbsp;k&nbsp;的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k&nbsp;个数字。滑动窗口每次只向右移动一位。返回 滑动窗口中的最大值 。1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^41 &lt;= k &lt;= nums.length 示例： 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 输入：nums = [1], k = 1输出：[1] 题解：遍历数组，将数存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。 class Solution { public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) { MyQueue que; vector&lt;int&gt; res; for(int i = 0; i &lt; k; ++i) que.push(nums[i]); res.push_back(que.front()); for(int i = k; i &lt; nums.size(); ++i) { que.pop(nums[i-k]); que.push(nums[i]); res.push_back(que.front()); } return res; } private: class MyQueue{ public: deque&lt;int&gt; que; void pop(int value) { if(!que.empty() &amp;&amp; value == que.front()) que.pop_front(); } void push(int value) { while(!que.empty() &amp;&amp; value &gt; que.back()) que.pop_back(); que.push_back(value); } int front() { return que.front(); } }; };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-347. 前 K 个高频元素","slug":"代码随想录/leetcode-347. 前 K 个高频元素","date":"2022-10-05T14:00:00.000Z","updated":"2022-10-05T16:06:42.286Z","comments":true,"path":"posts/a6b57153.html","link":"","permalink":"https://cotocode.github.io/posts/a6b57153.html","excerpt":"","text":"本题地址： leetcode-347. 前 K 个高频元素 题目描述： 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。1 &lt;= nums.length &lt;= 105k 的取值范围是 [1, 数组中不相同的元素的个数]题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 示例： **输入: **nums = [1,1,1,2,2,3], k = 2**输出: **[1,2] **输入: **nums = [1], k = 1**输出: **[1] 题解： class Solution { public: class mycomparison{ public: bool operator()(const pair&lt;int, int&gt;&amp; lhs, const pair&lt;int, int&gt;&amp; rhs) { return lhs.second &gt; rhs.second; } }; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { unordered_map&lt;int,int&gt; map; for(int i = 0; i &lt; nums.size(); ++i) map[nums[i]]++; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, mycomparison&gt; pri_que; // 用固定大小为k的小顶堆，扫面所有频率的数值 for (unordered_map&lt;int, int&gt;::iterator it = map.begin(); it != map.end(); it++) { pri_que.push(*it); if (pri_que.size() &gt; k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k pri_que.pop(); } } // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组 vector&lt;int&gt; result(k); for (int i = k - 1; i &gt;= 0; i--) { result[i] = pri_que.top().first; pri_que.pop(); } return result; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-1047. 删除字符串中的所有相邻重复项","slug":"代码随想录/leetcode-1047. 删除字符串中的所有相邻重复项","date":"2022-10-04T14:00:00.000Z","updated":"2022-10-05T16:05:11.131Z","comments":true,"path":"posts/79cfc748.html","link":"","permalink":"https://cotocode.github.io/posts/79cfc748.html","excerpt":"","text":"本题地址： leetcode-1047. 删除字符串中的所有相邻重复项 题目描述： 给出由小写字母组成的字符串&nbsp;S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。提示：1 &lt;= S.length &lt;= 20000S 仅由小写英文字母组成。 示例： 输入：“abbaca”输出：“ca”解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。 题解： class Solution { public: string removeDuplicates(string s) { stack&lt;char&gt; st; for(char ts : s) { if(st.empty() || st.top() != ts) st.push(ts); else st.pop(); } string res = \"\"; while(!st.empty()) { res += st.top(); st.pop(); } reverse(res.begin(),res.end()); return res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-150. 逆波兰表达式求值","slug":"代码随想录/leetcode-150. 逆波兰表达式求值","date":"2022-10-04T14:00:00.000Z","updated":"2022-10-05T16:05:14.354Z","comments":true,"path":"posts/77dbf1bb.html","link":"","permalink":"https://cotocode.github.io/posts/77dbf1bb.html","excerpt":"","text":"本题地址： leetcode-150. 逆波兰表达式求值 题目描述： 根据逆波兰表示法，求表达式的值。有效的算符包括&nbsp;+、-、、/&nbsp;。每个运算对象可以是整数，也可以是另一个逆波兰表达式。注意&nbsp;两个整数之间的除法只保留整数部分。可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。提示：1 &lt;= tokens.length &lt;= 10^4tokens[i]&nbsp;是一个算符（”+”、”-“、”“ 或 “/“），或是在范围 [-200, 200] 内的一个整数逆波兰表达式：逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。逆波兰表达式主要有以下两个优点：去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 示例： 输入：tokens = [“2”,”1”,”+”,”3”,”*”]输出：9解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 输入：tokens = [“4”,”13”,”5”,”/“,”+”]输出：6解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 输入：tokens = [“10”,”6”,”9”,”3”,”+”,”-11”,”“,”/“,”“,”17”,”+”,”5”,”+”]输出：22解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 题解： class Solution { public: int evalRPN(vector&lt;string&gt;&amp; tokens) { stack&lt;long&gt; st; for(int i = 0; i &lt; tokens.size(); ++i) { if(tokens[i] == \"+\" || tokens[i] == \"-\" || tokens[i] == \"*\" || tokens[i] == \"/\") { long num1 = st.top(); st.pop(); long num2 = st.top(); st.pop(); if (tokens[i] == \"+\") st.push(num2 + num1); else if (tokens[i] == \"-\") st.push(num2 - num1); else if (tokens[i] == \"*\") st.push(num2 * num1); else if (tokens[i] == \"/\") st.push(num2 / num1); } else st.push(stoi(tokens[i])); } int result = st.top(); st.pop(); return result; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-20. 有效的括号","slug":"代码随想录/leetcode-20. 有效的括号","date":"2022-10-02T14:00:00.000Z","updated":"2022-10-02T14:59:58.141Z","comments":true,"path":"posts/effee05c.html","link":"","permalink":"https://cotocode.github.io/posts/effee05c.html","excerpt":"","text":"本题地址： leetcode-20. 有效的括号 题目描述： 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’&nbsp;的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。每个右括号都有一个对应的相同类型的左括号。提示：1 &lt;= s.length &lt;= 104s 仅由括号 ‘()[]{}’ 组成 示例： 输入：s = “()”输出：true 输入：s = “()[]{}”输出：true 输入：s = “(]”输出：false 题解： class Solution { public: bool isValid(string s) { if (s.size() % 2 != 0) return false; stack&lt;char&gt; st; for(int i = 0; i &lt; s.size(); ++i) { if(s[i] == '(' || s[i] == '{' || s[i] == '[') st.push(s[i]); else if(st.empty()) return false; else if(s[i] == ')' &amp;&amp; st.top() == '(') st.pop(); else if(s[i] == '}' &amp;&amp; st.top() == '{') st.pop(); else if(s[i] == ']' &amp;&amp; st.top() == '[') st.pop(); else return false; } return st.empty(); } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-225. 用队列实现栈","slug":"代码随想录/leetcode-225. 用队列实现栈","date":"2022-10-02T14:00:00.000Z","updated":"2022-10-02T14:59:58.141Z","comments":true,"path":"posts/e9992c91.html","link":"","permalink":"https://cotocode.github.io/posts/e9992c91.html","excerpt":"","text":"本题地址： leetcode-225. 用队列实现栈 题目描述： 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。实现 MyStack 类：void push(int x) 将元素 x 压入栈顶。int pop() 移除并返回栈顶元素。int top() 返回栈顶元素。boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。注意：你只能使用队列的基本操作 —— 也就是&nbsp;push to back、peek/pop from front、size 和&nbsp;is empty&nbsp;这些操作。你所使用的语言也许不支持队列。&nbsp;你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列&nbsp;, 只要是标准的队列操作即可。提示：1 &lt;= x &lt;= 9最多调用100 次 push、pop、top 和 empty每次调用 pop 和 top 都保证栈不为空 示例： 输入：[“MyStack”, “push”, “push”, “top”, “pop”, “empty”][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False 题解： class MyStack { public: queue&lt;int&gt; que1; queue&lt;int&gt; que2; MyStack() { } void push(int x) { que1.push(x); } int pop() { int size = que1.size(); size--; while(size--) { que2.push(que1.front()); que1.pop(); } int result = que1.front(); que1.pop(); que1 = que2; while(!que2.empty()) que2.pop(); return result; } int top() { return que1.back(); } bool empty() { return que1.empty(); } }; /** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-232. 用栈实现队列","slug":"代码随想录/leetcode-232. 用栈实现队列","date":"2022-10-02T14:00:00.000Z","updated":"2022-10-02T14:59:58.141Z","comments":true,"path":"posts/b7f330e7.html","link":"","permalink":"https://cotocode.github.io/posts/b7f330e7.html","excerpt":"","text":"本题地址： leetcode-232. 用栈实现队列 题目描述： 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：实现 MyQueue 类：void push(int x) 将元素 x 推到队列的末尾int pop() 从队列的开头移除并返回元素int peek() 返回队列开头的元素boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明：你 只能 使用标准的栈操作 —— 也就是只有&nbsp;push to top,&nbsp;peek/pop from top,&nbsp;size, 和&nbsp;is empty&nbsp;操作是合法的。你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 1 &lt;= x &lt;= 9最多调用 100 次 push、pop、peek 和 empty假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 示例： 输入： [“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false 题解： class MyQueue { public: stack&lt;int&gt; stIn; stack&lt;int&gt; stOut; MyQueue() { } void push(int x) { stIn.push(x); } int pop() { if(stOut.empty()) { while(!stIn.empty()) { stOut.push(stIn.top()); stIn.pop(); } } int result = stOut.top(); stOut.pop(); return result; } int peek() { int res = this-&gt;pop(); stOut.push(res); return res; } bool empty() { return stIn.empty() &amp;&amp; stOut.empty(); } }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-151. 反转字符串中的单词","slug":"代码随想录/leetcode-151. 反转字符串中的单词","date":"2022-10-01T15:00:00.000Z","updated":"2022-10-01T15:06:53.535Z","comments":true,"path":"posts/e54f85fe.html","link":"","permalink":"https://cotocode.github.io/posts/e54f85fe.html","excerpt":"","text":"本题地址： leetcode-151. 反转字符串中的单词 题目描述： 给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。1 &lt;= s.length &lt;= 10^4s 包含英文大小写字母、数字和空格 ‘ ‘s 中至少存在一个 单词 示例： 输入：s = “the sky is blue”输出：“blue is sky the” 输入：s = “ &nbsp;hello world &nbsp;“输出：“world hello”解释：反转后的字符串中不能存在前导空格和尾随空格。 输入：s = “a good &nbsp; example”输出：“example good a”解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。 题解： class Solution { public: string reverseWords(string s) { removeExtraSpaces(s); reverse(s, 0, s.size() - 1); int start = 0; for(int i = 0; i &lt;= s.size(); ++i) { if(i == s.size() || s[i] == ' ') { reverse(s, start, i - 1); start = i + 1; } } return s; } void reverse(string &amp;s, int start, int end) { for(int i = start, j = end; i &lt; j; i++, j--) swap(s[i], s[j]); } void removeExtraSpaces(string&amp; s) { int slow = 0; for(int i = 0; i &lt; s.size(); ++i) { if(s[i] != ' ') { if(slow != 0) s[slow++] = ' '; while(s[i] != ' ' &amp;&amp; i &lt; s.size()) s[slow++] = s[i++]; } } s.resize(slow); } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-459. 重复的子字符串","slug":"代码随想录/leetcode-459. 重复的子字符串","date":"2022-10-01T15:00:00.000Z","updated":"2022-10-01T15:06:53.538Z","comments":true,"path":"posts/b7bd8f48.html","link":"","permalink":"https://cotocode.github.io/posts/b7bd8f48.html","excerpt":"","text":"本题地址： leetcode-459. 重复的子字符串 题目描述： 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。1 &lt;= s.length &lt;= 10^4s 由小写英文字母组成 示例： 输入: s = “abab”输出: true解释: 可由子串 “ab” 重复两次构成。 输入: s = “aba”输出: false 输入: s = “abcabcabcabc”输出: true解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。) 题解： class Solution { public: bool repeatedSubstringPattern(string s) { string t = s + s; t.erase(t.begin()); t.erase(t.end() - 1); if (t.find(s) != std::string::npos) return true; return false; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-剑指 Offer 05. 替换空格","slug":"代码随想录/leetcode-剑指 Offer 05. 替换空格","date":"2022-10-01T15:00:00.000Z","updated":"2022-10-01T15:06:53.539Z","comments":true,"path":"posts/7e602320.html","link":"","permalink":"https://cotocode.github.io/posts/7e602320.html","excerpt":"","text":"本题地址： leetcode-剑指 Offer 05. 替换空格 题目描述： 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。0 &lt;= s 的长度 &lt;= 10000 示例： 输入：s = “We are happy.”输出：“We%20are%20happy.” 题解： class Solution { public: string replaceSpace(string s) { int count = 0; int oldLength = s.size(); for(int i = 0; i &lt; oldLength; ++i) if(s[i] == ' ') ++count; s.resize(s.size() + 2 * count); int newlength = s.size(); int right = newlength - 1; int left = oldLength - 1; while(left &gt;= 0) { if(s[left] == ' ') { s[right--] = '0'; s[right--] = '2'; s[right--] = '%'; left--; } else s[right--] = s[left--]; } return s; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-剑指 Offer 58 - II. 左旋转字符串","slug":"代码随想录/leetcode-剑指 Offer 58 - II. 左旋转字符串","date":"2022-10-01T15:00:00.000Z","updated":"2022-10-01T15:06:53.540Z","comments":true,"path":"posts/768fde87.html","link":"","permalink":"https://cotocode.github.io/posts/768fde87.html","excerpt":"","text":"本题地址： leetcode-剑指 Offer 58 - II. 左旋转字符串 题目描述： 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。1 &lt;= k &lt; s.length &lt;= 10000 示例： 输入: s = “abcdefg”, k = 2**输出:&nbsp;**”cdefgab” 输入: s = “lrloseumgh”, k = 6**输出:&nbsp;**”umghlrlose” 题解：本题如果可以额外申请空间的话较简单，为提升难度，添加一个限制不能申请额外空间，只能在本串上进行操作。 class Solution { public: void reverseStr(string &amp;s, int left, int right) { while(left &lt; right) { char temp = s[left]; s[left++] = s[right]; s[right--] = temp; } } string reverseLeftWords(string s, int n) { reverseStr(s, 0, n - 1); reverseStr(s, n, s.size() - 1); reverseStr(s, 0, s.size() - 1); return s; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"剑指 Offer 04. 二维数组中的查找","slug":"剑指offer/剑指 Offer 04. 二维数组中的查找","date":"2022-09-30T14:00:00.000Z","updated":"2022-09-30T16:19:05.886Z","comments":true,"path":"posts/58b0f60b.html","link":"","permalink":"https://cotocode.github.io/posts/58b0f60b.html","excerpt":"","text":"本题地址：剑指 Offer 04. 二维数组中的查找注意：本题与主站 240 题相同：leetcode-240. 搜索二维矩阵 II 题目： 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。0 &lt;= n &lt;= 10000 &lt;= m &lt;= 1000 示例: 现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target&nbsp;=&nbsp;5，返回&nbsp;true。给定&nbsp;target&nbsp;=&nbsp;20，返回&nbsp;false。 题解： 从右上角开始走，利用这个顺序关系可以在O(m+n)的复杂度下解决这个题： 如果当前位置元素比target小，则row++ 如果当前位置元素比target大，则col-- 如果相等，返回true 如果越界了还没找到，说明不存在，返回false class Solution { public: bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) { if(matrix.empty() || matrix.size() == 0) return false; int m=matrix.size(); int n=matrix[0].size(); int row=0,col=n-1; while(row&lt;m&amp;&amp;col&gt;=0) { if(matrix[row][col]==target) return true; else if(matrix[row][col]&gt;target) col--; else row++; } return false; } };","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://cotocode.github.io/categories/%E5%89%91%E6%8C%87Offer/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://cotocode.github.io/tags/%E5%89%91%E6%8C%87Offer/"}],"author":"Co2"},{"title":"剑指 Offer 07. 重建二叉树","slug":"剑指offer/剑指 Offer 07. 重建二叉树","date":"2022-09-30T14:00:00.000Z","updated":"2022-09-30T16:19:05.888Z","comments":true,"path":"posts/73d0ff75.html","link":"","permalink":"https://cotocode.github.io/posts/73d0ff75.html","excerpt":"","text":"本题地址：剑指 Offer 07. 重建二叉树注意：本题与主站 105 题重复：leetcode-105.从前序与中序遍历序列构造二叉树 题目： 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。0 &lt;= 节点个数 &lt;= 5000 示例： Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7] 题解： 前序遍历性质： 节点按照 [ 根节点 | 左子树 | 右子树 ] 排序。中序遍历性质： 节点按照 [ 左子树 | 根节点 | 右子树 ] 排序。 根节点在前序遍历的索引 root 、子树在中序遍历的左边界left 、子树在中序遍历的右边界 right； 当 left &gt; right ，代表已经越过叶节点，此时返回 nullnull ；建立根节点 node ： 节点值为 preorder[root] ；划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；注意：该方法只适用于 “无重复节点值” 的二叉树。 根节点索引 中序遍历左边界 中序遍历右边界 左子树 root + 1 left i - 1 右子树 i - left + root + 1 i + 1 right class Solution { public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) { this-&gt;preorder = preorder; for(int i = 0; i &lt; inorder.size(); i++) dic[inorder[i]] = i; return recur(0, 0, inorder.size() - 1); } private: vector&lt;int&gt; preorder; unordered_map&lt;int, int&gt; dic; //三个索引分别为 //当前根的的索引 //递归树的左边界，即数组左边界 //递归树的右边界，即数组右边界 TreeNode* recur(int root, int left, int right) { if(left &gt; right) return nullptr; // 递归终止 TreeNode* node = new TreeNode(preorder[root]); // 建立根节点 int i = dic[preorder[root]]; // 划分根节点、左子树、右子树 //左子树的根的索引为先序中的根节点+1 //递归左子树的左边界为原来的中序in_left //递归左子树的右边界为中序中的根节点索引-1 node-&gt;left = recur(root + 1, left, i - 1); // 开启左子树递归 //右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1 //递归右子树的左边界为中序中当前根节点+1 //递归右子树的右边界为中序中原来右子树的边界 node-&gt;right = recur(root + i - left + 1, i + 1, right); // 开启右子树递归 return node; // 回溯返回根节点 } };","categories":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://cotocode.github.io/categories/%E5%89%91%E6%8C%87Offer/"}],"tags":[{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://cotocode.github.io/tags/%E5%89%91%E6%8C%87Offer/"}],"author":"Co2"},{"title":"leetcode-344. 反转字符串","slug":"代码随想录/leetcode-344. 反转字符串","date":"2022-09-30T14:00:00.000Z","updated":"2022-09-30T15:42:19.311Z","comments":true,"path":"posts/17a52ddc.html","link":"","permalink":"https://cotocode.github.io/posts/17a52ddc.html","excerpt":"","text":"本题地址： leetcode-344. 反转字符串 题目描述： 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。1 &lt;= s.length &lt;= 10^5s[i] 都是 ASCII 码表中的可打印字符 示例： 输入：s = [“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”] 输入：s = [“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”] 题解：Easy. class Solution { public: void reverseString(vector&lt;char&gt;&amp; s) { int left = 0, right = s.size() - 1; while(left &lt; right) { char temp = s[left]; s[left++] = s[right]; s[right--] = temp; } } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-541. 反转字符串 II","slug":"代码随想录/leetcode-541. 反转字符串 II","date":"2022-09-30T14:00:00.000Z","updated":"2022-09-30T15:42:19.311Z","comments":true,"path":"posts/8b5ba61e.html","link":"","permalink":"https://cotocode.github.io/posts/8b5ba61e.html","excerpt":"","text":"本题地址： leetcode-541. 反转字符串 II 题目描述： 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。1 &lt;= s.length &lt;= 10^4s 仅由小写英文组成1 &lt;= k &lt;= 10^4 示例： 输入：s = “abcdefg”, k = 2输出：“bacdfeg” 输入：s = “abcd”, k = 2输出：“bacd” 题解： class Solution { public: string reverseStr(string s, int k) { for (int i = 0; i &lt; s.size(); i += (2 * k)) if (i + k &lt;= s.size()) reverse(s.begin() + i, s.begin() + i + k ); else reverse(s.begin() + i, s.end()); return s; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-1. 两数之和","slug":"代码随想录/leetcode-1. 两数之和","date":"2022-09-28T14:00:00.000Z","updated":"2022-09-28T14:10:10.129Z","comments":true,"path":"posts/d0c90da7.html","link":"","permalink":"https://cotocode.github.io/posts/d0c90da7.html","excerpt":"","text":"本题地址： leetcode-1. 两数之和 题目描述： 给定一个整数数组 nums&nbsp;和一个整数目标值 target，请你在该数组中找出 和为目标值 target&nbsp; 的那&nbsp;两个&nbsp;整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。2 &lt;= nums.length &lt;= 10^4-10^9 &lt;= nums[i] &lt;= 10^9-10^9 &lt;= target &lt;= 10^9只会存在一个有效答案你可以想出一个时间复杂度小于 O(n^2) 的算法吗？ 示例： 输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 输入：nums = [3,2,4], target = 6输出：[1,2] 输入：nums = [3,3], target = 6输出：[0,1] 题解： class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { unordered_map&lt;int, int&gt; map; for(int i = 0; i &lt; nums.size(); ++i) { auto res = map.find(target - nums[i]); if(res != map.end()) return {res-&gt;second, i}; map.insert(pair&lt;int,int&gt;(nums[i],i)); } return {}; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-15. 三数之和","slug":"代码随想录/leetcode-15. 三数之和","date":"2022-09-28T14:00:00.000Z","updated":"2022-09-28T14:10:10.132Z","comments":true,"path":"posts/d5991cd4.html","link":"","permalink":"https://cotocode.github.io/posts/d5991cd4.html","excerpt":"","text":"本题地址： leetcode-15. 三数之和 题目描述： 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。3 &lt;= nums.length &lt;= 3000-10^5 &lt;= nums[i] &lt;= 10^5 示例： 输入：nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。 输入：nums = [0,1,1]输出：[]解释：唯一可能的三元组和不为 0 。 输入：nums = [0,0,0]输出：[[0,0,0]]解释：唯一可能的三元组和为 0 。 题解： class Solution { public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) { vector&lt;vector&lt;int&gt;&gt; result; sort(nums.begin(), nums.end()); for(int i = 0; i &lt; nums.size(); ++i) { if(nums[i] &gt; 0) return result; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) { continue; } int left = i + 1; int right = nums.size() - 1; while(right &gt; left) { if(nums[i] + nums[left] + nums[right] &gt; 0) right--; else if(nums[i] + nums[left] + nums[right] &lt; 0) left++; else { result.push_back(vector&lt;int&gt;{nums[i], nums[left], nums[right]}); while(right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--; while(right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++; right--; left++; } } } return result; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-242. 有效的字母异位词","slug":"代码随想录/leetcode-242. 有效的字母异位词","date":"2022-09-28T14:00:00.000Z","updated":"2022-09-28T14:10:10.133Z","comments":true,"path":"posts/deff244.html","link":"","permalink":"https://cotocode.github.io/posts/deff244.html","excerpt":"","text":"本题地址： leetcode-242. 有效的字母异位词 题目描述： 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。注意：若&nbsp;s 和 t&nbsp;中每个字符出现的次数都相同，则称&nbsp;s 和 t&nbsp;互为字母异位词。1 &lt;= s.length, t.length &lt;= 5 * 10^4s 和 t 仅包含小写字母 示例： 输入: s = “anagram”, t = “nagaram”输出: true 输入: s = “rat”, t = “car”**输出: **false 题解： class Solution { public: bool isAnagram(string s, string t) { if (s.size() != t.size()) return false; int hashs[26] = {0}; int hasht[26] = {0}; for(int i = 0; i &lt; s.size(); i++) { hashs[s[i] - 'a'] += 1; hasht[t[i] - 'a'] += 1; } for(int i = 0; i&lt;26; i++) { if(hashs[i] != hasht[i]) return false; } return true; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-349. 两个数组的交集","slug":"代码随想录/leetcode-349. 两个数组的交集","date":"2022-09-28T14:00:00.000Z","updated":"2022-09-28T14:10:10.134Z","comments":true,"path":"posts/94392b23.html","link":"","permalink":"https://cotocode.github.io/posts/94392b23.html","excerpt":"","text":"本题地址： leetcode-349. 两个数组的交集 题目描述： 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。1 &lt;= nums1.length, nums2.length &lt;= 10000 &lt;= nums1[i], nums2[i] &lt;= 1000 示例： 输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2] 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的 题解： class Solution { public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { vector&lt;int&gt; res; int hash[1005] = {0}; for(int i = 0; i &lt; nums1.size(); i++) hash[nums1[i]] = 1; for(int i = 0; i &lt; nums2.size(); i++) { if(hash[nums2[i]] != 0) { res.push_back(nums2[i]); hash[nums2[i]] = 0; } } return res; } }; class Solution { public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { unordered_set&lt;int&gt; res; unordered_set&lt;int&gt; nums(nums1.begin(),nums1.end()); for(int num : nums2) { if(nums.find(num) != nums.end()) res.insert(num); } return vector&lt;int&gt;(res.begin(), res.end()); } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-383. 赎金信","slug":"代码随想录/leetcode-383. 赎金信","date":"2022-09-28T14:00:00.000Z","updated":"2022-09-28T14:10:10.135Z","comments":true,"path":"posts/134d59a4.html","link":"","permalink":"https://cotocode.github.io/posts/134d59a4.html","excerpt":"","text":"本题地址： leetcode-383. 赎金信 题目描述： 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。1 &lt;= ransomNote.length, magazine.length &lt;= 10^5ransomNote 和 magazine 由小写英文字母组成 示例： 输入：ransomNote = “a”, magazine = “b”输出：false 输入：ransomNote = “aa”, magazine = “ab”输出：false 输入：ransomNote = “aa”, magazine = “aab”输出：true 题解： class Solution { public: bool canConstruct(string ransomNote, string magazine) { int hash[26] = {0}; for(int i = 0; i &lt; magazine.size(); ++i) hash[magazine[i] - 'a'] += 1; for(int i = 0; i &lt; ransomNote.size(); ++i) if(--hash[ransomNote[i] - 'a'] &lt; 0) return false; return true; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-454. 四数相加 II","slug":"代码随想录/leetcode-454. 四数相加 II","date":"2022-09-28T14:00:00.000Z","updated":"2022-09-28T14:10:10.135Z","comments":true,"path":"posts/61eec703.html","link":"","permalink":"https://cotocode.github.io/posts/61eec703.html","excerpt":"","text":"本题地址： leetcode-454. 四数相加 II 题目描述： 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：0 &lt;= i, j, k, l &lt; nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0n == nums1.lengthn == nums2.lengthn == nums3.lengthn == nums4.length1 &lt;= n &lt;= 200-2^28 &lt;= nums1[i], nums2[i], nums3[i], nums4[i] &lt;= 2^28 示例： 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出：2解释：两个元组如下： (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出：1 题解：类似两数之和，但相对较简单些，因为四个数组相对独立，不需要考虑有重复的四个元素相加等于0的情况，将数组nums1和nums2的和存放在map中,另一个数为数组nums3和nums4中元素的和 class Solution { public: int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) { unordered_map&lt;int,int&gt; map; for(int a : nums1) for(int b : nums2) map[a + b]++; int res = 0; for(int c : nums3) for(int d : nums4) { res += map[0 - c - d]; } return res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-面试题 02.07. 链表相交","slug":"代码随想录/leetcode-面试题 02.07. 链表相交","date":"2022-09-18T08:00:09.000Z","updated":"2022-09-18T08:53:21.385Z","comments":true,"path":"posts/9703af79.html","link":"","permalink":"https://cotocode.github.io/posts/9703af79.html","excerpt":"","text":"本题地址： leetcode-面试题 02.07. 链表相交 题目描述： 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。listA 中节点数目为 mlistB 中节点数目为 n0 &lt;= m, n &lt;= 3 * 1041 &lt;= Node.val &lt;= 1050 &lt;= skipA &lt;= m0 &lt;= skipB &lt;= n如果 listA 和 listB 没有交点，intersectVal 为 0如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 示例： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Intersected at ‘8’解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 输入：intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Intersected at ‘2’解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。 题解： class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { int lenA = 0, lenB = 0; ListNode *curA = headA,*curB = headB; while(curA != NULL) { lenA++; curA = curA-&gt;next; } while(curB != NULL) { lenB++; curB = curB-&gt;next; } curA = headA; curB = headB; while(lenA &gt; lenB) { curA = curA-&gt;next; lenA--; } while(lenA &lt; lenB) { curB = curB-&gt;next; lenB--; } while(curA != NULL) { if(curA == curB) return curA; curA = curA-&gt;next; curB = curB-&gt;next; lenA--; lenB--; } return NULL; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-19. 删除链表的倒数第 N 个结点","slug":"代码随想录/leetcode-19. 删除链表的倒数第 N 个结点","date":"2022-09-18T08:00:08.000Z","updated":"2022-09-18T08:53:06.843Z","comments":true,"path":"posts/74d16850.html","link":"","permalink":"https://cotocode.github.io/posts/74d16850.html","excerpt":"","text":"本题地址： leetcode-19. 删除链表的倒数第 N 个结点 题目描述： 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。链表中结点的数目为 sz1 &lt;= sz &lt;= 300 &lt;= Node.val &lt;= 1001 &lt;= n &lt;= sz 示例： 输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5] 输入：head = [1], n = 1输出：[] 输入：head = [1,2], n = 1输出：[1] 题解： class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* prehead = new ListNode(); prehead-&gt;next = head; ListNode* fast = prehead; ListNode* slow = prehead; while(n &amp;&amp; fast != nullptr) { fast = fast-&gt;next; --n; } fast = fast-&gt;next; while(fast != nullptr) { slow = slow-&gt;next; fast = fast-&gt;next; } slow-&gt;next = slow-&gt;next-&gt;next; return prehead-&gt;next; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-24. 两两交换链表中的节点","slug":"代码随想录/leetcode-24. 两两交换链表中的节点","date":"2022-09-18T08:00:08.000Z","updated":"2022-09-18T08:52:44.668Z","comments":true,"path":"posts/9d230ec7.html","link":"","permalink":"https://cotocode.github.io/posts/9d230ec7.html","excerpt":"","text":"本题地址： leetcode-24. 两两交换链表中的节点 题目描述： 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。链表中节点的数目在范围 [0, 100] 内0 &lt;= Node.val &lt;= 100 示例： 输入：head = [1,2,3,4]输出：[2,1,4,3] 输入：head = []输出：[] 输入：head = [1]输出：[1] 题解： class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode* prehead = new ListNode(0,head); ListNode* cur = prehead; while(cur-&gt;next != nullptr &amp;&amp; cur-&gt;next-&gt;next != nullptr) { ListNode* temp1 = cur-&gt;next; ListNode* temp2 = cur-&gt;next-&gt;next-&gt;next; cur-&gt;next = temp1-&gt;next; cur-&gt;next-&gt;next = temp1; temp1-&gt;next = temp2; cur = cur-&gt;next-&gt;next; } return prehead-&gt;next; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-206. 反转链表","slug":"代码随想录/leetcode-206. 反转链表","date":"2022-09-18T08:00:07.000Z","updated":"2022-09-18T08:52:38.091Z","comments":true,"path":"posts/88bc9a63.html","link":"","permalink":"https://cotocode.github.io/posts/88bc9a63.html","excerpt":"","text":"本题地址： leetcode-206. 反转链表 题目描述： 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。链表中节点的数目范围是 [0, 5000]-5000 &lt;= Node.val &lt;= 5000链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 示例： 输入：head = [1,2,3,4,5]输出：[5,4,3,2,1] 输入：head = [1,2]输出：[2,1] 输入：head = [] 输出：[] 题解：非递归，双指针法。 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode *pre = nullptr, *cur = head, *temp; while(cur) { temp = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = temp; } return pre; } }; 递归。 class Solution { public: ListNode* reverse(ListNode* pre, ListNode* cur) { if(cur == nullptr) return pre; ListNode* temp; temp = cur-&gt;next; cur-&gt;next = pre; return reverse(cur, temp); } ListNode* reverseList(ListNode* head) { return reverse(nullptr,head); } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-707. 设计链表","slug":"代码随想录/leetcode-707. 设计链表","date":"2022-09-18T08:00:06.000Z","updated":"2022-09-18T08:52:29.939Z","comments":true,"path":"posts/c7392cd.html","link":"","permalink":"https://cotocode.github.io/posts/c7392cd.html","excerpt":"","text":"本题地址： leetcode-707. 设计链表 题目描述： 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val&nbsp;和&nbsp;next。val&nbsp;是当前节点的值，next&nbsp;是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性&nbsp;prev&nbsp;以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。在链表类中实现这些功能：get(index)：获取链表中第&nbsp;index&nbsp;个节点的值。如果索引无效，则返回-1。addAtHead(val)：在链表的第一个元素之前添加一个值为&nbsp;val&nbsp;的节点。插入后，新节点将成为链表的第一个节点。addAtTail(val)：将值为&nbsp;val 的节点追加到链表的最后一个元素。addAtIndex(index,val)：在链表中的第&nbsp;index&nbsp;个节点之前添加值为&nbsp;val&nbsp; 的节点。如果&nbsp;index&nbsp;等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。deleteAtIndex(index)：如果索引&nbsp;index 有效，则删除链表中的第&nbsp;index 个节点。所有val值都在 [1, 1000] 之内。操作次数将在 [1, 1000] 之内。请不要使用内置的 LinkedList 库。 示例： MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3linkedList.get(1); //返回3 题解： class MyLinkedList { public: struct LinkedNode { int val; LinkedNode* next; LinkedNode(int val):val(val), next(nullptr){} }; MyLinkedList() { Head = new LinkedNode(0); size = 0; } int get(int index) { if (index &gt; (size - 1) || index &lt; 0) { return -1; } LinkedNode* cur = Head-&gt;next; while(index--){ cur = cur-&gt;next; } return cur-&gt;val; } void addAtHead(int val) { LinkedNode* newNode = new LinkedNode(val); newNode-&gt;next = Head-&gt;next; Head-&gt;next = newNode; size++; } void addAtTail(int val) { LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = Head; while(cur-&gt;next != nullptr){ cur = cur-&gt;next; } cur-&gt;next = newNode; size++; } void addAtIndex(int index, int val) { if (index &gt; size || index &lt; 0) { return; } LinkedNode* newNode = new LinkedNode(val); LinkedNode* cur = Head; while(index--) { cur = cur-&gt;next; } newNode-&gt;next = cur-&gt;next; cur-&gt;next = newNode; size++; } void deleteAtIndex(int index) { if (index &gt;= size || index &lt; 0) { return; } LinkedNode* cur = Head; while(index--) { cur = cur -&gt;next; } LinkedNode* tmp = cur-&gt;next; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; size--; } void printLinkedList() { LinkedNode* cur = Head; while (cur-&gt;next != nullptr) { cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; \" \"; cur = cur-&gt;next; } cout &lt;&lt; endl; } private: int size; LinkedNode* Head; }; /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-203. 移除链表元素","slug":"代码随想录/leetcode-203. 移除链表元素","date":"2022-09-18T08:00:05.000Z","updated":"2022-09-18T08:51:47.481Z","comments":true,"path":"posts/f3dab808.html","link":"","permalink":"https://cotocode.github.io/posts/f3dab808.html","excerpt":"","text":"本题地址： leetcode-203. 移除链表元素 题目描述： 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。列表中的节点数目在范围 [0, 10^4] 内1 &lt;= Node.val &lt;= 500 &lt;= val &lt;= 50 示例： 输入：head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5] 输入：head = [], val = 1输出：[] 输入：head = [7,7,7,7], val = 7输出：[] 题解： /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { while(head != nullptr &amp;&amp; head-&gt;val == val) head = head-&gt;next; if(head == nullptr) return head; ListNode* temp = head; while(temp-&gt;next != nullptr) { if(temp-&gt;next-&gt;val == val) temp-&gt;next = temp-&gt;next-&gt;next; else temp = temp-&gt;next; } return head; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-59. 螺旋矩阵 II","slug":"代码随想录/leetcode-59. 螺旋矩阵 II","date":"2022-09-18T08:00:04.000Z","updated":"2022-09-18T08:51:41.832Z","comments":true,"path":"posts/157ac6d3.html","link":"","permalink":"https://cotocode.github.io/posts/157ac6d3.html","excerpt":"","text":"本题地址： leetcode-59. 螺旋矩阵 II 题目描述： 给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 示例： 输入：n = 3输出：[[1,2,3],[8,9,4],[7,6,5]] 输入：n = 1输出：[[1]] 题解： class Solution { public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) { vector&lt;vector&lt;int&gt;&gt; res(n, vector&lt;int&gt;(n, 0)); int startx = 0, starty = 0; int length = n - 1; int curnum = 1; for(int i = 0; i &lt; n/2; ++i) { int curx = startx, cury = starty; for(int j = 0;j &lt; length; ++j) res[curx][cury++] = curnum++; for(int j = 0;j &lt; length; ++j) res[curx++][cury] = curnum++; for(int j = 0;j &lt; length; ++j) res[curx][cury--] = curnum++; for(int j = 0;j &lt; length; ++j) res[curx--][cury] = curnum++; startx = startx + 1; starty = starty + 1; length -= 2; } if(n%2==1) res[n/2][n/2]=curnum; return res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-209. 长度最小的子数组","slug":"代码随想录/leetcode-209. 长度最小的子数组","date":"2022-09-18T08:00:03.000Z","updated":"2022-09-18T08:51:30.305Z","comments":true,"path":"posts/c13c9a32.html","link":"","permalink":"https://cotocode.github.io/posts/c13c9a32.html","excerpt":"","text":"本题地址： leetcode-209. 长度最小的子数组 题目描述： 给定一个含有&nbsp;n&nbsp;个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组&nbsp;[numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。如果你已经实现_ _O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 示例： 输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组&nbsp;[4,3]&nbsp;是该条件下的长度最小的子数组。 输入：target = 4, nums = [1,4,4]输出：1 输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0 题解：通过滑动窗口法，for循环遍历终止位置， class Solution { public: int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) { int i = 0, sum = 0, sublength=0; int res = 0x3f3f3f3f; for(int j = 0; j &lt; nums.size(); ++j) { sum +=nums[j]; while(sum &gt;= target) { sublength = j - i + 1; if(sublength &lt; res) res = sublength; sum -= nums[i]; ++i; } } return res == 0x3f3f3f3f ? 0 : res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-977. 有序数组的平方","slug":"代码随想录/leetcode-977. 有序数组的平方","date":"2022-09-18T08:00:02.000Z","updated":"2022-09-18T08:51:22.986Z","comments":true,"path":"posts/3d539b1a.html","link":"","permalink":"https://cotocode.github.io/posts/3d539b1a.html","excerpt":"","text":"本题地址： leetcode-977. 有序数组的平方 题目描述： 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例： 输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121] 题解：数组是有序的， 只不过负数平方之后可能成为最大数了。那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。此时可以考虑双指针法了，left指向起始位置，right指向终止位置。定义一个新数组res，和nums数组一样的大小，让index指向result数组终止位置。向res中逐个插入元素。 class Solution { public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) { int left = 0,right = nums.size()-1; vector&lt;int&gt; res(nums.size(),0); int index=nums.size()-1; while(index&gt;=0) { if(nums[left]*nums[left] &gt; nums[right]*nums[right]) { res[index] = nums[left]*nums[left]; left++; } else { res[index] = nums[right]*nums[right]; right--; } index--; } return res; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-27. 移除元素","slug":"代码随想录/leetcode-27. 移除元素","date":"2022-09-18T08:00:01.000Z","updated":"2022-09-18T08:51:13.122Z","comments":true,"path":"posts/f17d5e68.html","link":"","permalink":"https://cotocode.github.io/posts/f17d5e68.html","excerpt":"","text":"本题地址： leetcode-27. 移除元素 题目描述： 给你一个数组 nums&nbsp;和一个值 val，你需要 原地 移除所有数值等于&nbsp;val&nbsp;的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例： 输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,4,0,3]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 题解：双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。定义快慢指针 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组 慢指针：指向更新 新数组下标的位置class Solution { public: int removeElement(vector&lt;int&gt;&amp; nums, int val) { int slowIndex=0; for(int fastIndex=0;fastIndex&lt;nums.size();fastIndex++) { if(nums[fastIndex]!=val) nums[slowIndex++]=nums[fastIndex]; } return slowIndex; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-704. 二分查找","slug":"代码随想录/leetcode-704. 二分查找","date":"2022-09-18T08:00:00.000Z","updated":"2022-09-18T08:52:20.201Z","comments":true,"path":"posts/bec86256.html","link":"","permalink":"https://cotocode.github.io/posts/bec86256.html","excerpt":"","text":"本题地址： leetcode-704. 二分查找 题目描述： 给定一个&nbsp;n&nbsp;个元素有序的（升序）整型数组&nbsp;nums 和一个目标值&nbsp;target &nbsp;，写一个函数搜索&nbsp;nums&nbsp;中的 target，如果目标值存在返回下标，否则返回 -1。你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。nums 的每个元素都将在 [-9999, 9999]之间。 示例： 输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 题解： class Solution { public: int search(vector&lt;int&gt;&amp; nums, int target) { int left = 0, right = nums.size() - 1; while(left &lt;= right) { int index = (left + right)/2; if(nums[index] == target) return index; else if(nums[index] &gt; target) right = index - 1; else left = index + 1; } return -1; } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"leetcode-1207. 独一无二的出现次数","slug":"leetcode/leetcode-1207. 独一无二的出现次数","date":"2022-09-18T07:00:00.000Z","updated":"2022-09-18T07:36:05.075Z","comments":true,"path":"posts/f39bdc82.html","link":"","permalink":"https://cotocode.github.io/posts/f39bdc82.html","excerpt":"","text":"本题地址： leetcode-1207. 独一无二的出现次数 题目描述： 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。1 &lt;= arr.length &lt;= 1000-1000 &lt;= arr[i] &lt;= 1000 示例： 输入：arr = [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 输入：arr = [1,2]输出：false 输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]输出：true 题解： class Solution { public: bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) { int count[2002] = {0}; // 统计数字出现的频率 for (int i = 0; i &lt; arr.size(); i++) { count[arr[i] + 1000]++; } bool fre[1002] = {false}; // 看相同频率是否重复出现 for (int i = 0; i &lt;= 2000; i++) { if (count[i]) { if (fre[count[i]] == false) fre[count[i]] = true; else return false; } } return true; } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"}],"author":"Co2"},{"title":"leetcode-204. 计数质数","slug":"leetcode/leetcode-204. 计数质数","date":"2022-09-18T07:00:00.000Z","updated":"2022-09-18T07:36:05.075Z","comments":true,"path":"posts/81dea3c7.html","link":"","permalink":"https://cotocode.github.io/posts/81dea3c7.html","excerpt":"","text":"本题地址： leetcode-204. 计数质数 题目描述： 给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。0 &lt;= n &lt;= 5 * 10^6 示例： 输入：n = 10输出：4解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。 输入：n = 0输出：0 输入：n = 1输出：0 题解：埃氏筛该算法由希腊数学家厄拉多塞（Eratosthenes）提出，称为厄拉多塞筛法，简称埃氏筛。我们考虑这样一个事实：如果 x 是质数，那么大于 x 的 倍数 2x,3x,… 一定不是质数.我们设isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。 class Solution { public: int countPrimes(int n) { vector&lt;int&gt; isPrime(n,1); int ans=0; for(int i=2;i&lt;n;++i) { if(isPrime[i]) { ans+=1; if((long long)i*i&lt;n) { for(int j=i*i;j&lt;n;j+=i) isPrime[j]=0; } } } return ans; } }; 线性筛 class Solution { public: int countPrimes(int n) { vector&lt;int&gt; primes; vector&lt;int&gt; isPrime(n, 1); for (int i = 2; i &lt; n; ++i) { if (isPrime[i]) { primes.push_back(i); } for (int j = 0; j &lt; primes.size() &amp;&amp; i * primes[j] &lt; n; ++j) { isPrime[i * primes[j]] = 0; if (i % primes[j] == 0) { break; } } } return primes.size(); } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"}],"author":"Co2"},{"title":"leetcode-41. 缺失的第一个正数","slug":"leetcode/leetcode-41. 缺失的第一个正数","date":"2022-09-18T07:00:00.000Z","updated":"2022-09-18T07:36:05.085Z","comments":true,"path":"posts/201d9742.html","link":"","permalink":"https://cotocode.github.io/posts/201d9742.html","excerpt":"","text":"本题地址： leetcode-41. 缺失的第一个正数 题目描述： 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。1 &lt;= nums.length &lt;= 5 * 10^5-2^31 &lt;= nums[i] &lt;= 2^31 - 1 示例： 输入：nums = [1,2,0]输出：3 输入：nums = [3,4,-1,1]输出：2 输入：nums = [7,8,9,11,12]输出：1 题解： class Solution { public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) { const int length=nums.size(); int temp[500000]={0}; for(int num:nums) { if(num&gt;0&amp;&amp;num&lt;=length) temp[num-1]=1; } int res=0; for(int i=0;i&lt;500000;++i) { if(temp[i]==0) { res=i+1; break; } } return res; } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"}],"author":"Co2"},{"title":"leetcode-692. 前K个高频单词","slug":"leetcode/leetcode-692. 前K个高频单词","date":"2022-09-18T07:00:00.000Z","updated":"2022-09-18T07:36:05.075Z","comments":true,"path":"posts/e11a3502.html","link":"","permalink":"https://cotocode.github.io/posts/e11a3502.html","excerpt":"","text":"本题地址： leetcode-692. 前K个高频单词 题目描述： 给定一个单词列表&nbsp;words&nbsp;和一个整数 k ，返回前&nbsp;k&nbsp;个出现次数最多的单词。返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率， 按字典顺序 排序。1 &lt;= words.length &lt;= 5001 &lt;= words[i] &lt;= 10words[i]&nbsp;由小写英文字母组成。k 的取值范围是&nbsp;[1, 不同 words[i] 的数量] 示例： 输入: words = [“i”, “love”, “leetcode”, “i”, “love”, “coding”], k = 2输出: [“i”, “love”]解析: “i” 和 “love” 为出现次数最多的两个单词，均为2次。注意，按字母顺序 “i” 在 “love” 之前。 输入: [“the”, “day”, “is”, “sunny”, “the”, “the”, “the”, “sunny”, “is”, “is”], k = 4输出: [“the”, “is”, “sunny”, “day”]解析: “the”, “is”, “sunny” 和 “day” 是出现次数最多的四个单词，出现次数依次为 4, 3, 2 和 1 次。 题解：哈希加排序。 class Solution { public: vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) { unordered_map&lt;string, int&gt; Map; for (string s : words) Map[s]++; vector&lt;pair&lt;string, int&gt;&gt; vec; for (auto index = Map.begin(); index != Map.end(); ++index) vec.emplace_back(*index); return HeapSort(vec, k); } vector&lt;string&gt; HeapSort(vector&lt;pair&lt;string, int&gt;&gt;&amp; vec, int k) { int n = vec.size() - 1; for (int i = (n + 1) / 2 - 1; i &gt;= 0; --i) AdjustHeap(vec, i, n); vector&lt;string&gt; res(k); for (int i = 0; i &lt; k; ++i) { res[i] = vec[0].first; vec[0] = vec[n - i]; AdjustHeap(vec, 0, n - i - 1); } return res; } void AdjustHeap(vector&lt;pair&lt;string, int&gt;&gt;&amp; vec, int root, int end) { int parent = root; int son = parent * 2 + 1; while (son &lt;= end) { if (son + 1 &lt;= end &amp;&amp; (vec[son].second &lt; vec[son + 1].second || (vec[son].second == vec[son + 1].second &amp;&amp; vec[son].first &gt; vec[son + 1].first))) ++son; if (vec[parent].second &lt; vec[son].second || (vec[son].second == vec[parent].second &amp;&amp; vec[parent].first &gt; vec[son].first)) { swap(vec[parent], vec[son]); parent = son; son = parent * 2 + 1; } else return; } } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"}],"author":"Co2"},{"title":"leetcode-202.快乐数","slug":"代码随想录/leetcode-202. 快乐数","date":"2022-08-21T13:00:00.000Z","updated":"2022-09-18T16:22:07.309Z","comments":true,"path":"posts/57a0e4d.html","link":"","permalink":"https://cotocode.github.io/posts/57a0e4d.html","excerpt":"","text":"本题地址： leetcode-202.快乐数 题目描述： 编写一个算法来判断一个数 n 是不是快乐数。「快乐数」&nbsp;定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为&nbsp;1，那么这个数就是快乐数。如果 n 是 快乐数 就返回 true ；不是，则返回 false 。1 &lt;= n &lt;= 2^31 - 1 示例： 输入：n = 19输出：true解释：12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 输入：n = 2输出：false 题解： class Solution { public: bool isHappy(int n) { int hash[6000]={0}; int num=0; while(1) { while(n&gt;0) { num+=(n%10)*(n%10); n=n/10; } if(num==1) return true; if(hash[num]==1) return false; hash[num]=1; n=num; num=0; } } };","categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"}],"author":"Co2"},{"title":"哈希表","slug":"数据结构/哈希表","date":"2022-08-21T13:00:00.000Z","updated":"2022-08-21T16:02:05.414Z","comments":true,"path":"posts/850f2080.html","link":"","permalink":"https://cotocode.github.io/posts/850f2080.html","excerpt":"","text":"哈希表(hash table)又叫散列表，是一种关联式容器，存储的是一对值，一般是一个key对应一个value(又叫键值对)。数组、链表、栈、队列都是序列式容器，存储的都是一个元素。C++ STL中的map就是一个散列表。 散列函数：散列函数的要求： hash(key)的结果是非负整数(数组下标) if(key1==key2)，hash(key1)==hash(key2) if(key1!=key2)，hash(key1)!=hash(key2) 然而实际情况中，第三点是基本做不到的，就算是著名的哈希算法MD5,SHA都难以避免会有不同key算出相同的hash值的情况，又称为哈希冲突。哈希算法有很多种，但是好的哈希算法应该尽量少地出现哈希冲突。 哈希冲突：解决方法：开放地址法、链表法、建立公共溢出区。 开放地址法（1）线性探测法当我们的所需要存放值的位置被占了，我们就往后面一直加1并对m取模直到存在一个空余的地址供我们存放值，取模是为了保证找到的位置在0~m-1的有效空间之中。 存在问题：出现非同义词冲突（两个不想同的哈希值，抢占同一个后续的哈希地址）被称为堆积或聚集现象。公式： h(x)=(Hash(x)+i)mod (Hashtable.length)（i会逐渐递增加1） （2）平方探测法（二次探测）当我们的所需要存放值的位置被占了，会前后寻找而不是单独方向的寻找。公式： h(x)=(Hash(x) +k)mod (Hashtable.length)（k依次为+(i^2)和-(i^2)）（i会逐渐递增加1） （3）再哈希法：同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个……等其他的哈希函数计算地址，直到不发生冲突为止。虽然不易发生聚集，但是增加了计算时间。 链表法链表法在数组的每个槽都维护一个链表，当发生散列冲突的时候，存储在链表的结点里，插入、查找、删除的时间复杂就是链表插入、查找、删除的时间复杂度。 建立公共溢出区将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中。 两种方法优缺点比较开放地址法：优点：所有数据都存在数组里，可以有效利用CPU缓存所有数据都存在数组里，便于序列化缺点：删除需要使用特殊标志发生冲突时插入查找删除都需要探测，代价较高装载因子不能太大，需要提前申请好内存，这也导致了比链表法更加浪费内存适用情况：数据量小，装载因子小。 链表法：优点：需要的时候才申请结点而不是一开始就申请好，内存利用率更高对装载因子容忍度高，就算装载因子很大，只要哈希函数分布比较平均，链表长度虽然变长，但是相当于均摊到每一条链表了，所以比起纯数组还是要快。当数据量大时，可以使用红黑树或者跳表代替链表实现优化，使得查找效率从O(n)变成O(logn)。缺点：链表结点在内存中不连续，对CPU缓存不友好需要存储额外的指针，如果存储小的对象会消耗更多的内存，如果存储较大的对象的话指针的消耗可以忽略不计。适用情况：存储大对象，大数据量。 装载因子装载因子loadfactor = 填入表中的元素个数 / 散列表的长度 装载因子越大，说明散列表越满，哈希冲突的概率越大，开放地址法的探测次数增加，链表法的链表长度会增大，导致散列表的性能会下降。 一般我们会为装载因子设置一个阈值，当到达或者超过这个阈值后散列表进行动态扩容。 装载因子的阈值设置需要权衡时间，空间的需求。如果对内存充足，对执行效率性能要求比较高，可以将阈值设置小一点；如果内存紧张，对执行效率性能要求不敏感，可以将阈值设置大一些，甚至可以超过1。Java的HashMap中默认的最大装载因子是0.75。 动态扩容上面说到装载因子达到某个阈值时，散列表需要动态扩容以减小散列冲突：申请更大的数组空间，旧数据重新计算哈希值，搬移到新的空间上。 在实际中，如果我们提供对外服务，在插入某个数据后启动动态扩容，一次性将所有旧数据计算哈希值并搬移到新空间上，可能会导致某一段时间无法响应用户的请求。 因此，在动态扩容时，我们可以先申请空间，但是先不计算哈希值和搬移数据。在需要插入新数据时，我们将新数据插入新的空间，然后从旧散列表中取一个数据计算哈希值插入新的空间里。这样的话在查找的时候也需要兼顾新旧两个散列表，先从新散列表里找，如果找不到再到旧散列表里找。 这种做法我们将动态扩容均摊到插入操作中，每次插入操作的时间复杂度是O(1)，这样的做法会更加地柔和，避免了一次性动态扩容耗时过高。 实现：（链表法）定义链表结点结构体struct Item { string key; string value; Item* next; Item() { this-&gt;key = \"empty\"; this-&gt;value = \"empty\"; this-&gt;next = nullptr; } Item(string k, string v) { this-&gt;key = k; this-&gt;value = v; this-&gt;next = nullptr; } }; 初始化哈希表const int tablesize = 20; struct Item* hashtable[tablesize]; void InitHashtable() { for (int i = 0; i &lt; tablesize; ++i) hashtable[i] = new Item(); } 哈希函数int hashFunction(string key) { int sum = 0; for (int i = 0; i &lt; key.size(); ++i) sum += static_cast&lt;int&gt;(key[i]); return sum % tablesize; } 在链表中的位置int NumOfList(string keys) { int index = hashFunction(keys); int num = 1; struct Item* temp = hashtable[index]-&gt;next; while (temp-&gt;key != keys) { temp = temp-&gt;next; ++num; } return num; } 插入这里需要注意的是，数组的槽里的结点是不存储数据的，也就是table[i]这个结点是不存储数据的，可以理解成是一个哨兵，table[i]-&gt;next所指向的结点才是第一个存储数据的。 void AddItem(string key, string value) { int index = hashFunction(key); struct Item* temp = new Item(key, value); temp-&gt;next = hashtable[index]-&gt;next; hashtable[index]-&gt;next = temp; } 查找计算哈希值，然后遍历链表。 void FindValue(string key, int&amp; index, int&amp; num) { index = hashFunction(key); num = NumOfList(key); } 删除先找这个结点，找到了就删除这个结点。 void DeleteItem(string key) { int index = 0, num = 0; FindValue(key, index, num); struct Item* temp = hashtable[index]; for (int i = num; i &gt; 1; --i) { temp = temp-&gt;next; } temp-&gt;next = temp-&gt;next-&gt;next; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Co2"},{"title":"堆","slug":"数据结构/堆","date":"2022-08-21T13:00:00.000Z","updated":"2022-08-21T16:02:05.414Z","comments":true,"path":"posts/fab451a5.html","link":"","permalink":"https://cotocode.github.io/posts/fab451a5.html","excerpt":"","text":"堆基础二叉堆（以大根堆为例）：堆的数据结构：堆一般使用数组存储。当堆中有n个元素的时，可以将这些元素存放在数组heap的前n个单元里，其中堆的根节点中元素存放在heap[1]中。结点之间的关系有两种情况： 如果根节点在数组中的位置是1，那么第i个位置的左右节点下标分别为2i、2i+1，父节点下标为 i/2。 如果根节点在数组中的位置是0，那么第i个位置的左右节点下标分别为2i+1、2i+2，父节点下标为 (i-1)/2。struct Heap { public: //EType为自定义类型 int *heap; //存放数据的空间，下标从1开始存储数据，下标为0的作为工作空间，存储临时数据。 int HeapSize; //HeapSize是堆元素的个数 int MaxSize; //MaxSize是堆中最多存放元素数量 Heap(int maxsize) //init { MaxSize = maxsize; HeapSize = 0; heap = new int[maxsize + 1]; } ~Heap() //free memory { delete heap; } }; 初始化堆：int Maxsize = 20; Heap *H = new Heap(Maxsize); 交换堆中元素：//把堆中的a,b位置的值互换 void swap(Heap &amp;H, int a, int b) { //临时存储child位置的值 int temp = H.heap[a]; //把index的值赋给child的位置 H.heap[a] = H.heap[b]; //把原来的child位置的数值赋值给index位置 H.heap[b] = temp; } 向上调整：递归实现：void HeapUp(Heap &amp;H, int index) { //注意由于数值是从下标为1开始，当index = 1的时候，已经是根节点了 if (index &gt; 1) { //求出父亲的节点 int parent = index / 2; //获取相应位置的数值 int parentValue = H.heap[parent]; int indexValue = H.heap[index]; //如果父亲节点比index的数值小，就交换二者的数值 if (parentValue &lt; indexValue) { //交换数值 swap(H, parent, index); //递归调用 HeapUp(H, parent); } } } 非递归实现：void HeapUp(Heap &amp;H, int index) { int parent = 0; while (index &gt; 1) { //获取index的父节点的下标 parent = index / 2; //获得父节点的值 int parentValue = H.heap[parent]; //获得index位置的值 int indexValue = H.heap[index]; //如果父节点的值小就交换 if (parentValue &lt; indexValue) { swap(H, parent, index); } index = parent; } } 向下调整：递归实现：void HeapDown(Heap &amp;H, int index) { int n = H.HeapSize; //记录最大的那个儿子节点的位置 int child = -1; if (2 * index &gt; n) { //2*index&gt;n说明该节点没有左右儿子节点了，那么就返回 return; } else if (2 * index == n) { //如果只有一个儿子（左儿子节点） child = 2 * index; } else if (2 * index &lt; n) { //如果左右儿子都存在 //定义左儿子节点 child = 2 * index; //如果左儿子小于右儿子的数值，取右儿子的下标 if (H.heap[child] &lt; H.heap[child+1]) { child++; } } if (H.heap[child] &gt; H.heap[index]) { //交换堆中的child，和index位置的值 swap(H, child, index); //完成交换后递归调用，继续下降 HeapDown(H, child); } } 非递归实现：void HeapDown(Heap &amp;H, int index) { int child = 0;//存储左儿子的位置 int temp = H.heap[index]; int n = H.HeapSize; //如果有儿子的话 while (2 * index &lt;= n) { //获取左儿子的位置 child = 2 * index; //如果有右儿子且右儿子数值比左儿子大 if (child &lt; n&amp;&amp;H.heap[child + 1]&gt;H.heap[child]) { child = child + 1; } //如果数值最大的儿子比temp的值大 if (H.heap[child] &gt; temp) { swap(H, index, child); index = child; } else break; } } 插入元素：void Insert(Heap &amp;H, int value) { //如果堆没满,堆数据数量加一，最后一个位置放入新数据 if (H.HeapSize &lt; H.MaxSize) { H.HeapSize++; H.heap[H.HeapSize] = value; //最后一个数据上升到合适位置 HeapUp(H, H.HeapSize); } else return; } 删除元素：oid Delete(Heap &amp;H, int index) { //把最后的一个叶子的数值赋值给index位置 H.heap[index] = H.heap[H.HeapSize]; //堆元素个数减一 H.HeapSize--; //index节点下沉到合适位置 HeapDown(H, index); } 调整堆：void Adjust(Heap &amp;H) { //从第Heapsize/2个元素到第1个元素逐个HeapDown int n = H.HeapSize / 2; while (n &gt;= 1) { HeapDown(H, n); --n; } } 堆排序：void HeapSort(Heap &amp;H, int a[], int length) { for (int i = 0; i &lt; length; ++i) Insert(H, a[i]); while (H.HeapSize &gt; 0) { cout &lt;&lt; H.heap[1] &lt;&lt; endl; Delete(H, 1); } } d叉堆：d叉堆与二叉堆的区别是d叉堆是完全d叉树。 操作 二叉堆 d叉堆 insert O(logN) O(log(d)N) delete O(logN) O(d*log(d)N) merge O(N*logN) O(N*log(d)N) 堆进阶https://blog.csdn.net/gdut2015go/article/details/46706323 左偏树：Skewed Heap：Van Emde Boas Tree：","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Co2"},{"title":"字典树","slug":"数据结构/字典树","date":"2022-08-21T13:00:00.000Z","updated":"2022-08-21T16:02:05.414Z","comments":true,"path":"posts/eea60a6a.html","link":"","permalink":"https://cotocode.github.io/posts/eea60a6a.html","excerpt":"","text":"字典树（Trie树），又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。 字典树3个基本性质 根节点不包含字符，除根节点外每一个节点都只包含一个字符。 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。 每个节点的所有子节点包含的字符都不相同。 trie树每一层的节点数是26^i级别的。所以为了节省空间。用动态链表，或者用数组来模拟动态。空间的花费，不会超过单词数×单词长度。 字典树优缺点优点：1、插入，查询，删除等操作复杂度为O(h),其中h为单词的长度。为什么会这么快呢，本质是空间换时间（空间复杂度为26的h次方），利用指针来避免做其他不必要的查找。（初始化的时间复杂度为n O(h),n为单词个数）2、当储存大量单词或者说储存的单词有着共同前缀时节省了空间。（比如说用线性存储boy,boyfriend如用trie存储的差别）缺点：指针占用的空间，空间复杂度大。如果储存少量的单词，并不能节省空间。 字典树的应用 字符串检索：事先将已知的一些字符串（字典）的有关信息保存到trie树里，查找另外一些未知字符串是否出现过或者出现频率。 字符串最长公共前缀（转化为寻找共同祖先问题）。与哈希的比较 Tire Hash 初始化 nO(h) O(n) 查询、插入、删除 O(h) O(1) 空间复杂度 26^h n 查询公共前缀单词 O(h) O(n) 词频统计 nO(h) O(n) 能否节省空间 Yes No 实现字典树结构体TrieNode的结点结构中没有直接使用一个成员来保存结点值。而是使用字母映射表next，next中保存了对当前结点而言下一个可能出现的字符 struct TrieNode { bool isend;//字符串结束标志 TrieNode* next[26];//字母映射表 TrieNode() { this-&gt;isend = false; for (int i = 0; i &lt; 26; ++i) this-&gt;next[i] = nullptr; } }; 插入从根节点开始遍历，如果当前结点的字母映射表next中不存在word[i]，则在当前结点的next[word[i]]处建立一个新的结点，并将当前结点移动到next[word[i]]处，直到将word全部插入，还要将最后一个结点的isend置为true。 void Insert(string word) { TrieNode* temp = Trie; for (char ch : word) { if (temp-&gt;next[ch - 'a'] == nullptr) { temp-&gt;next[ch - 'a'] = new TrieNode(); } temp = temp-&gt;next[ch - 'a']; } temp-&gt;isend = true; } 查找查找word是否存在于Trie中 (注：查找必须要在到达word最后一个字符时，字典树也到达isend为true 的结点，也就是说word不能以前缀的形式存在于Trie中)。从字典树的根节点开始，与word中的字符进行匹配，如果不存在word中某个字符的映射，则说明字典树中不包含这个单词，返回false。将word遍历完后若没有返回false，再判断isend是否为true。 bool Find(string word) { TrieNode* temp = Trie; for (char ch : word) { temp = temp-&gt;next[ch - 'a']; if (temp == nullptr) return false; } return temp-&gt;isend; } 前缀匹配与查找相比，前缀匹配只要求word在字典树的一条根节点开始的分支中。所以我们不再需要判断isend的值。 bool prefix(string word) { TrieNode* temp = Trie; for (char ch : word) { temp = temp-&gt;next[ch - 'a']; if (temp == nullptr) return false; } return true; }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Co2"},{"title":"并查集","slug":"数据结构/并查集","date":"2022-08-21T13:00:00.000Z","updated":"2022-08-21T16:02:05.414Z","comments":true,"path":"posts/c517589e.html","link":"","permalink":"https://cotocode.github.io/posts/c517589e.html","excerpt":"","text":"并查集基础定义 并查集是一种树型的数据结构，主要用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。一些常见的用途有连通子图、最小生成树的Kruskal算法和求最近公共祖先等。 并查集的实现与优化并查集的原理： 每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，pre[x]表示x的父节点。 如果x为树根的话，pre[x]=x （x的父节点指向自己） 求x的集合编号（x的祖宗节点）：while(pre[x] != x ) x = pre[x]; 合并两个集合，将x的根节点嫁接到y的根节点，如：prex是x的集合编号，prey是y的集合编号，嫁接：pre[prex]= prey;代码实现int f[maxn]; //全名为 father，父节点的意思 //初始化 n个元素 void Init() { //使每个元素的根节点是其本身 //即初始时每个元素都是单独的 for(int i=1; i&lt;=n; i++) f[i]=i; } //查询树的根 //非递归实现 int Find(int i) { while(f[i] != i) //直到元素的父节点是它本身，表示已经查询到了树的根 i = f[i]; return i; //返回根节点对应的元素 } //递归实现 int Find(int i) { if(f[i]==i) //若元素的根节点为其本身，那么此元素就是树的根 return f[i]; //直接返回元素本身即可 else return Find(f[i]); //否则继续查询，知道查询到树的根位置 } //简化版 int Find(int i) { return f[i]==i ? f[i] : Find(f[i]); } //合并 void merge(int a, int b) { //先找到两个元素对应的根对应的元素 int fa = Find(a); int fb = Find(b); if(fa==fb) return; else f[fa]=fb; //否则令元素 a的根指向元素 b的根 } //简化版 void merge(int a, int b) { f[Find(a)] = Find(b); } 代码优化优化1：按秩合并首先，我们合并时，可记录这棵树的高度（记为rank）。接下来当我们需合并两棵树时，我们先对两棵树的高度进行判断，如不同，则让高度小的树的根指向高度大的根。//初始化优化 int f[maxn]; int h[maxn]; //全名为 height void Init() { for(int i=1; i&lt;=n; i++) { f[i] = i; h[i] = 0; //令每棵树的高度初始值都为 0 } } //合并优化 void merge(int a, int b) { int fa = Find(a); int fb = Find(b); if(fa==fb) return; if(h[fa] &lt; h[fb]) { //如果元素 a对应的树的高度比 b小 f[fa] = fb; //使元素 a的根指向元素 b的根 } else { f[fb] = fa; //否则让元素 b的根指向元素 a的根 if(h[fa] == h[fb]) h[fa]++; // 如果两者对应的树的高度相同，则使新生成的树高度 +1 } } 优化2：路径压缩由于查询时我们需沿着元素所在的树从下往上查询，最终找到这棵树的根，表明这个元素与其根对应元素属于同一组。因为在此查询过程中我们会经过许多节点，而如果我们能将这个元素直接指向根节点，那么就能节省许多查询的时间。同时，在查询过程中，每次经过的节点，我们都可以同时将他们一起直接指向根节点。这样做的话，我们再查询这些节点时，就能很快知道他们的根是谁了。//查询优化 int Find(int i) { return f[i]==i ? f[i] : f[i] = Find(f[i]); //使元素直接指向树的根 } 最终代码实现void Init() { for(int i=0; i&lt;=n; i++) { f[i] = i; h[i] = 0; } } int Find(int i) { return f[i]==i ? f[i] : f[i]=Find(f[i]); } void merge(int a, int b) { int fa = Find(a); int fb = Find(b); if(fa != fb) { if(h[fa] &lt; h[fb]) { f[fa] = fb; } else { f[fb] = fa; if(h[fa] == h[fb]) h[fa]++; } } } 并查集入门模板题https://blog.csdn.net/weixin_51250927/article/details/113621645并查集进阶带权并查集定义：带权是指一个元素具有额外的信息。比如元素1对应着数值6，元素2对应着数值4。这些带有信息的元素组成的并查集即为带权并查集。作用：带权并查集能计算各个小组中元素的个数、能计算n个元素中还有几个元素没有加入小组中；计算分数、距离等等注释：带权并查集需要在路径优化的基础下进行。带权并查集模板题：https://blog.csdn.net/weixin_51250927/article/details/113620822种类并查集定义;种类并查集是能把并查集分为几个部分，每个部分的种类不同。作用：种类并查集能将两个阵容分开。比如把好人和坏人分为两个阵营。https://blog.csdn.net/weixin_51250927/article/details/113617248https://blog.csdn.net/weixin_51250927/article/details/113619285","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Co2"},{"title":"Leetcode题目表","slug":"leetcode/leetcode题目表","date":"2022-08-13T05:00:00.000Z","updated":"2022-09-18T07:33:38.063Z","comments":true,"path":"posts/94f69fa5.html","link":"","permalink":"https://cotocode.github.io/posts/94f69fa5.html","excerpt":"","text":"Part1-基础题基础题-一维数组 题目 难度 Go 1、两数之和 Easy 15、三数之和 Easy 16、最接近的三数之和 Easy 18、四数之和 Easy 217、存在重复元素 Easy 219、存在重复元素II Easy 228、汇总区间 Easy 280、摆动排序 Easy 349、两个数组的交集 Easy 350、两个数组的交集 Easy 414、第三大的数 Easy 581、最短无序连续子数组 Easy 605、种花问题 也是很不错的题目 Easy 628、三个数的最大乘积 Easy 643、子数组最大平均数 I Easy 665、非递减数列 很好的题 Easy 674、最长连续递增序列 Easy 697、数组的度 Easy 717、1比特与2比特字符 Easy 724、寻找数组的中心索引 Easy 747、至少是其他数字两倍的最大数 Easy 849、到最近的人的最大距离 好题 Easy 914、卡牌分组 这也是道好题 Easy 989、数组形式的整数加法 Easy 1128、等价多米诺骨牌对的数量 Easy 11、盛最多水的容器 Medium 42、接雨水 Medium 128、最长连续序列 Medium 189、旋转数组 Medium 324、摆动排序II Medium 442、数组中重复的数据 Medium 457、环形数组是否存在循环 Medium 611、有效三角形的个数 Medium 31、下一个排列 (7+) Hard 41、缺失的第一个正数 (7+) Hard 基础题-二维矩阵 题目 难度 Go 36 有效的数独 Easy 554 砖墙 Easy 48 旋转图像 Medium 54 螺旋矩阵 Medium 59 螺旋矩阵II Medium 73 矩阵置零 Medium 240 搜索二维矩阵 Medium 剑指 Offer 04. 二维数组中的查找 289 生命游戏 Medium 419 甲板上的战舰 Medium 463 岛屿周长 Medium 498 对角线遍历 Medium 723 粉碎糖果 Medium 1706 球会落何处 Medium 基础题-字符串 题目 难度 Go 6、Z字变换 Easy 13、罗马数字转整数 Easy 49、字母异位词分组 Easy 58、最后一个单词的长度 Easy 67、二进制求和 Easy 125、验证回文串 Easy 151、翻转字符串里的单词 Easy 165、比较版本号 Easy 205、同构字符串 Easy 290、单词规律 Easy 299、猜数字游戏 Easy 344、反转字符串 Easy 383、赎金信 Easy 392、判断子序列 Easy 434、字符串中的单词数 Easy 482、密钥格式化 Easy 680、验证回文字符串 Ⅱ Easy 686、重复叠加字符串匹配 Easy 819、最常见的单词 Easy 859、亲密字符串 Easy 8、字符串转换整数 Medium 17、电话号码的字母组合 Medium 65、有效数字 Medium 165、比较版本号 Medium 1332、删除回文子序列 Medium 2047、句子中有效的单词数 Medium 777、在LR字符串中交换相邻字符 Hard Part2-数据结构题链表 题目 难度 Go 2 两数相加 Easy 19 删除链表的倒数第N个结点 Easy 21 合并两个有序链表 Easy 61、旋转链表 Easy 82、删除排序链表中的重复元素 Easy 83、删除排序链表中的重复元素 Easy 86、分隔链表 Easy 141、环形链表 Easy 147、对链表进行插入排序 Easy 206、反转链表 Easy 237、删除链表中的节点 Easy 369 单链表加一 Easy 445 两数相加II Easy 707 设计链表 Easy 23 合并K个升序链表 Medium 24 两两交换链表中的节点 Medium 25 K个一组翻转链表 Medium 138 复制带随机指针的链表 Medium 142 环形链表II Medium 148 排序链表 Medium 160 相交链表 Medium 234 回文链表 Medium 328 奇偶链表 Medium 二叉树二叉树-树结构与基础算法 题目 难度 Go 94、二叉树的中序遍历 Easy 95、不同的二叉搜索树 II Easy 96、不同的二叉搜索树 Easy 98、验证二叉搜索树 Easy 99、恢复二叉搜索树 Easy 100、相同的树 Easy 101、对称二叉树 Easy 102、二叉树的层序遍历 Easy 103、二叉树的锯齿形层序遍历 Easy 104、二叉树的最大深度 Easy 105、从前序与中序遍历序列构造二叉树 Easy 剑指 Offer 07. 重建二叉树 106、从中序与后序遍历序列构造二叉树 Easy 107、二叉树的层序遍历 II Easy 108、将有序数组转换为二叉搜索树 Easy 109、有序链表转换二叉搜索树 Easy 110、平衡二叉树 Easy 111、二叉树的最小深度 Easy 112、路径总和 Easy 113、路径总和 II Easy 114、二叉树展开为链表 Medium 226 翻转二叉树 Easy 314 二叉树的垂直遍历 Easy 144 二叉树的前序遍历 递归：Easy 迭代：Medium 116、填充每个节点的下一个右侧节点指针 Medium 117、填充每个节点的下一个右侧节点指针 II Medium 222 完全二叉树的节点个数 Medium 230 二叉搜索树的第K小元素 Medium 236 二叉树的最近公共祖先 Medium 297 二叉树的序列化与反序列化 Medium 331 验证二叉树的前序序列化 Medium 662 二叉树最大宽度 Medium 889 前序与后序序列构造二叉树 Medium 145 二叉树的后序遍历 递归：Easy 迭代：Hard 二叉树-树形DP 题目 难度 Go 124 二叉树中的最大路径和 Medium 333 最大BST子树 Medium 337 打家劫舍III Medium 687 最长同值路径 Medium 2313 二叉树得到结果的最少翻转次数 Medium 968 监控二叉树 Hard 多叉树 题目 难度 Go 429 N叉树的层序遍历 Easy 427 建立四叉树 Medium 428 序列化和反序列化N叉树 Medium 1490 克隆N叉树 Medium 1516 移动N叉树的子树 Medium 1522 N叉树的直径 Medium 431 将N叉树编码为二叉树 Hard 图图-图结构与基础图算法 题目 难度 Go 323 无向图中连通分量的数目 Easy 547 省份数量 Easy 797 所有可能的路径 Easy 1971 寻找图中是否存在路径 Easy 133 克隆图 Medium 261 以图判树 Medium 332 重新安排行程 Medium 743 网络延迟时间 Medium 785 判断二分图 Medium 787 K站中转内最便宜的航班 Medium 802 找到最终的安全状态 Medium 847 访问所有节点的最短路径 Medium 1719 重构一棵树的方案数 very Hard 图-最短路 题目 难度 Go 1334 阈值距离内邻居最少的城市 Medium 1976 到达目的地的方案数 Hard 2203 得到要求路径的最小带权子图 Hard 图-拓扑排序 题目 难度 Go 207 课程表 Medium 210 课程表II Medium 269 火星词典 Medium 2050 并行课程III Medium 310 最小高度树 Hard 444 序列重建 Hard 2127 参加会议的最多员工数 very Hard 栈栈-基础 题目 难度 Go 20、有效的括号 (3) Easy 71、简化路径 (3) Easy 150、逆波兰表达式求值 (5-) Medium 155、最小栈 (4-) Medium 224、基本计算器 (5+) Medium 225、用队列实现栈 (4+) Medium 227、基本计算器II (6-) Medium 232、用栈实现队列 (4+) Medium 394、字符串解码 Medium 636、函数的独占时间 Medium 682、棒球比赛 Medium 726、原子的数量 (6) Medium 739、每日温度 经典 Medium 844、比较含退格的字符串 Medium 856、括号的分数 Medium 921、使括号有效的最少添加 Medium 946、验证栈序列 (4+) Medium 1003、检查替换后的词是否有效 Medium 1047、删除字符串中的所有相邻重复项 Medium 1190、反转每对括号间的子串 Medium 1209、删除字符串中的所有相邻重复项 Medium 32、最长有效括号 (7+) Hard 栈-单调栈 题目 难度 Go 255 验证前序遍历二叉搜索树序列 Medium 402 移掉K位数字 Medium 496 下一个更大元素 Medium 503 下一个更大元素II Medium 84 柱状图最大矩形 Hard 85、最大矩形 Hard 316 去除重复字母 Hard 907 子数组的最小值之和 Hard 2289 使数组按非递减顺序排列 very Hard 堆（优先队列） 题目 难度 Go 215 数组中的第K个最大元素 (4+) Medium leetcode-215. 数组中的第K个最大元素 239 滑动窗口最大值 (6) Medium 253 会议室II (4+) Medium 347 前K个高频元素 (5+) Medium leetcode-347. 前 K 个高频元素 358 K距离间隔重排字符串 (6+) Medium 373 查找和最小的K对数字 (6) Medium 502 IPO (6+) Medium 295 数据流的中位数 (7) Hard 407 接雨水II (8+) Hard 480 滑动窗口中位数 (10-) very Hard 字典树 题目 难度 Go 208 实现前缀树 (3) Easy 720 词典中最长的单词 (3+) Easy 211 添加与搜索单词 (4) Medium 212 单词搜索II (6-) Medium 676 实现一个魔法字典 (5+) Medium 1804 实现前缀树II (4) Medium 472 连接词 (7-) Hard 并查集 题目 难度 Go 1971.寻找图中是否存在路径 Easy 305 岛屿数量II Medium 547.省份数量 Medium 1627 带阈值的图连通性 Medium 并查集+埃氏筛 1697 检查边长度限制的路径是否存在 Medium 2092 找出知晓秘密的所有专家 Medium 2204 无向图中到环的距离 Medium 1579 保证图可完全遍历 Hard 2076 处理含限制条件的好友请求 Hard 哈希表 题目 难度 Go 202、快乐数 Easy leetcode-202.快乐数 204、计数质数 Easy 205、同构字符串 Easy 290、单词规律 Easy 387、字符串中的第一个唯一字符 Easy 594、最长和谐子序列 Easy 599、两个列表的最小索引总和 Easy 645、错误的集合 Easy 720、词典中最长的单词 Easy 884、两句话中的不常见单词 Easy 970、强整数 看的答案，豁然开朗 Easy 1207、独一无二的出现次数 Easy 3、无重复字符的最长子串 Medium 215、数组中的第K个最大元素 经典 Medium 347、前 K 个高频元素 Medium 380、常数时间插入、删除和获取随机元素 Medium 451、根据字符出现频率排序 Medium 648、单词替换 Medium 692、前K个高频单词 Medium 718、最长重复子数组 经典 Medium Part3-算法题BFS 题目 难度 Go 286 墙与门 Easy 127 单词接龙 Medium 317 离建筑物的最近距离 Medium 417 太平洋大西洋 Medium 773 滑动谜题 Medium 815 公交路线 Medium 909 蛇梯棋 Medium 2146 价格范围内最高排名的 K 样物品 Medium 2290 到达角落需要移除障碍物的最少数量 Medium 126 单词接龙II Hard DFS 题目 难度 Go 690 员工的重要性 Easy 130 被围绕的区域 Medium 200 岛屿数量 Medium 339 嵌套列表权重和 Medium 341 扁平嵌套列表迭代器 Medium 529 扫雷游戏 Medium DPDP-递推公式 题目 难度 Go 70 爬楼梯 (3-) Easy 118 杨辉三角 (2) Easy 119 杨辉三角II (2) Easy DP-打家劫舍 题目 难度 Go 91 解码方法 (3) Easy 198 打家劫舍 (3-) Easy 213 打家劫舍II (3+) Easy 639 解码方法II (5) Medium 740 删除并获得点数 (5-) Medium DP-子数组问题 题目 难度 Go 53 最大子序和 (4-) Medium 152 乘积最大子数组 (5+) Medium 718 最长公共子数组 (4) Medium DP-股票问题 题目 难度 Go 121 买卖股票的最佳时机 (3+) Easy 122 买卖股票的最佳时机II (3) 可贪心解 Easy 309 买卖股票的最佳时机冷冻 (5) Medium 714 买卖股票的最佳时机手续费 (4) 可贪心解 Medium 2054 两个最好的不重叠活动 (6+) Medium 123 买卖股票的最佳时机III (7-) Hard 188 买卖股票的最佳时机IV (7) Hard 1751 最多可以参加的会议数目II (7-) Hard 1235 规划兼职工作 (7-) Hard DP-一维数组（平方级时间复杂度） 题目 难度 Go 279 完全平方数 Medium 可用数学方法解 300 最长递增子序列 Medium 可用贪心+二分 343 整数拆分 Medium 可用数学方法解 368 最大整除子集 Medium 650 只有两个键的键盘 Medium 可用数学方法解 DP-二维路径和问题 题目 难度 Go 62 不同路径 Easy 63 不同路径II Easy 64 最小路径和 Easy 120 三角形最小路径和 Easy 174 地下城游戏 Medium 221 最大正方形 Medium 329 矩阵中的最长递增路径 Medium 记忆化搜索实现 DP-字符串 题目 难度 Go 72 编辑距离 (6) Medium 115 不同的子序列 (6+) Medium 1143 最长公共子序列 (6) Medium 10 正则表达式匹配 (8+) Hard 44 通配符匹配 (7) Hard 97 交错字符串 (7-) Hard 1987 不同的好子序列数目 (9-) Hard DP-回文字符串 题目 难度 Go 5 最长回文子串 Medium 131 分割回文串 Medium DP预处理+回溯 132 分割回文串II Medium 516 最长回文子序列 Medium DP-背包问题 题目 难度 Go 322 零钱兑换 Medium 377 组合总和IV Medium 416 分割等和子集 Medium 474 一和零 Medium 518 零钱兑换II Medium 2218 从栈中取出 K 个硬币的最大面值和 Hard 分组背包 DP-粉刷房子 题目 难度 Go 256 粉刷房子 (3) Easy 276 栅栏涂色 (3) Easy 265 粉刷房子II (5) Medium 552 学生出勤记录II (5+) Medium DP-状态压缩 题目 难度 Go 464 我能赢吗 Hard 记忆化搜索实现，博弈问题 1349 参加考试的最大学生数 Hard 2172 数组的最大与和 Hard 三进制状态压缩 2247 K次旅行的最大花费 Hard DP与图论结合 DP-区间 题目 难度 Go 375 猜数字大小II Medium 486 预测赢家 Medium DP-其他 题目 难度 Go 600 不含连续1的非负整数 Medium 264 丑数II Hard 313 超级丑数 Hard 808 分汤 Hard DP算概率 837 新21点 Hard DP算概率 1477 找两个和为目标值且不重叠的子数组 Hard DP+滑动窗口/前缀和 546 移除盒子 very Hard 3维DP数组，难度极高 1397 找到所有好字符串 very Hard 数位DP+KMP，全网顶级hard之一 2060 同源字符串检测 very Hard 3~4维DP数组，难度极高 贪心 题目 难度 Go 455 分发饼干 Easy 605 种花问题 Easy 781 森林中的兔子 Easy 944、删列造序 Easy 1029、两地调度 Easy 1046、最后一块石头的重量 Easy 1049、最后一块石头的重量 II Easy 1217、玩筹码 Easy 1221、分割平衡字符串 Easy 1877 数组中最大数对和的最小值 Easy 1953 你可以工作的最大周数 Easy 11 最多水的容器 Medium 45 跳跃游戏II Medium 135 分发糖果 Medium 334 递增的三元子序列 Medium 406 根据身高重建队列 Medium 435 无重叠区间 Medium 452 用最少数量的箭引爆气球 Medium 678 有效括号字符串 Medium 1147 段式回文 Medium 2268 最少按键次数 Medium 134 加油站 Hard 330 按要求补齐数组 Hard 517 超级洗衣机 Hard 659 分割数组为连续子序列 Hard 1686 石子游戏VI Hard 2350 不可能得到的最短骰子序列 Hard 2071 你可以安排的最多任务数目 very Hard 贪心+二分+优先/单调队列综合 回溯回溯-初识回溯 题目 难度 Go 17 电话号码的字母组合 Easy 回溯-排列组合子集问题 题目 难度 Go 46 全排列 (3) Easy 78 子集 (3+) Easy 39 组合总和 (4-) Medium 40 组合总和II (5) Medium 47 全排列II (4) Medium 77 组合 (4-) Medium 78、子集 Medium 90 子集II (4+) Medium 回溯-其他高级问题 题目 难度 Go 526 优美的排列 Easy 37 解数独 Medium 51 N皇后 Medium 79 单词搜索 Medium 93 复原IP地址 Medium 254 因子的组合 Medium 291 单词规律II Medium 294 翻转游戏II Medium 301 删除无效的括号 Medium 679 24点游戏 Medium 996 正方形数组的数目 Medium 1240 铺瓷砖 Hard 二分查找二分-基本型 题目 难度 Go 33 搜索旋转排序数组 Easy 34 在排序数组中查找元素的第一个和最后一个位置 Easy 35 搜索插入位置 Easy 81 搜索旋转排序数组II Easy 167、两数之和 II - 输入有序数组 Easy 278、第一个错误的版本 Easy 367、有效的完全平方数 Easy 374、猜数字大小 Easy 441、排列硬币 Easy 475、供暖器,很经典 Easy 704 二分查找 Easy 744、寻找比目标字母大的最小字母 Easy 1095、山脉数组中查找目标值 Easy 二分-进阶型 题目 难度 Go 29、两数相除 Medium 153、寻找旋转排序数组中的最小值 Medium 162 寻找峰值 Medium 275 H指数II Medium 436、寻找右区间,很好的题 Medium 454、四数相加 II Medium 540 有序数组中的单一元素 Medium 792、匹配子序列的单词数 Medium 1818 绝对差值和 Medium 4 寻找两个正序数组中位数 Hard 302 包含全部黑色像素 Hard 1901 找出顶峰元素II Hard 1964 最长递增子序列进阶 Hard 二分-转化判定问题（俗称二分猜答案） 题目 难度 Go 69 Sqrt Easy 410 分割数组的最大值 Medium 875 爱吃香蕉的珂珂 Medium 1970 穿过矩阵的最后一天 Medium 287 寻找重复数 Hard 378 有序矩阵的第K小元素 Hard 前缀和前缀和-普通型 题目 难度 Go 303 区域检索-数组不可变 Easy 1480 一维数组的动态和 Easy 238 除自身以外数组的乘积 Medium 523 连续的子数组和 Medium 525 连续数组 Medium 528 按权重随机选择 Medium 560 和为K的子数组 Medium 2245 转角路径的乘积中最多能有几个尾随零 Hard 二维矩阵中的一维前缀和+数学 2281 巫师的总力量和 Hard 单调栈+前缀和的前缀和 前缀和-二维 题目 难度 Go 304 区域检索-矩阵不可变 Medium 1314 矩阵区域和 Medium 前缀和-构造差分数组 题目 难度 Go 370 区间加法 Medium 1094 拼车 Medium 1109 航班预定统计 Medium 798 得分最高的最小轮调 Hard 2132 用邮票贴满网格图 Hard 二维差分数组+两次二维前缀和 滑动窗口 题目 难度 Go 187 重复的DNA序列 (3) Easy 209 长度最小的子数组 (3+) Easy 438 找到字符串中所有字母异位词 (3+) Easy 3 无重复字符的最长子串 (4-) Medium 30 串联所有单词的子串 (6) Medium 340 最多包含K个不同字符的最长子串 (5-) Medium 424 替换后的最长重复字符 (4) Medium 713 乘积小于K的子数组 (4) Medium 76 最小覆盖子串 (7-) Hard 分治 题目 难度 Go 1274 矩形内船只的数目 Medium 932 漂亮数组 Hard 1763 最长的美好子字符串 Hard 位运算 题目 难度 Go 136 只出现一次的数字 Easy 371 两整数之和 Easy 477 汉明距离总和 Easy 1310 子数组异或查询 Easy 201 数字范围按位与 Medium 260 只出现一次的数字III Medium 318 最大单词长度乘积 Medium 982 按位与为零的三元组 Medium 1284 转化为全零矩阵的最少反转次数 Medium 1734 解码异或后的排列 Medium 2313 操作后的最大异或和 Medium 137 只出现一次的数字II Hard 421 数组中两个数的最大异或 Hard 898 子数组按位或操作 Hard 2354 优质数对的数目 Hard Part4-数学题数学-模拟竖式 题目 难度 Go 66 加一 Easy 166 分数到小数 Easy 415 字符串相加 Easy 43 字符串相乘 Medium 数学-进制转换 题目 难度 Go 171 Excel表序号 Easy 405 转换为十六进制数 Easy 168 Excel表名称 Medium 数学-几何 题目 难度 Go 149 直线最多的点 Medium 223 矩形面积 Medium 296 最佳碰头地点 Medium 356 直线镜像 Medium 462 最少移动次数使数组元素相等 Medium 593 有效的正方形 Medium 335 路径交叉 Hard 数学-其他 题目 难度 Go 268 丢失的数字 (2+) Easy 292 Nim游戏 (2) Easy 357 计算各个位数不同的数字个数 (3+) Easy 60 排列序列 Medium 172 阶乘后的零 Medium 204 计数质数 Medium 233 数字1的个数 Medium 258 各位相加 Medium 319 灯泡开关 Medium 360 有序转化数组 Medium 365 水壶问题 Medium 1518 换酒问题 Medium 458 可怜的小猪 Hard 483 最小好进制 Hard 1735 生成乘积数组的方案数 Hard 1823 找出游戏的获胜者 Hard 经典约瑟夫环问题 Part5-设计题 题目 难度 Go 1570 两个稀疏向量的点积 Easy 271 字符串的编解码 Medium 284 窥探迭代器 Medium 348 井字棋 Medium 353 贪吃蛇 Medium 355 设计推特 Medium 380 O(1)插入删除随机不重复 Medium 381 O(1)插入删除随机有重复 Medium 1500 设计文件分享系统 Medium 2296 设计一个文本编辑器 Medium 146 LRU缓存 Hard 352 将数据流变为多个不相交区间 Hard 460 LFU缓存 Hard 1206 设计跳表 Hard","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"}],"author":"Co2"},{"title":"C++黑马程序员---五、函数高级","slug":"C++黑马程序员/C++黑马程序员---函数高级","date":"2022-08-06T09:00:00.000Z","updated":"2022-08-06T09:33:08.138Z","comments":true,"path":"posts/8f5bca0f.html","link":"","permalink":"https://cotocode.github.io/posts/8f5bca0f.html","excerpt":"","text":"5.1 函数默认参数语法：返回类型 函数名（参数=默认值）{}注意事项： 如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值。如果函数的声明有默认参数，函数实现就不能有默认参数。（编译器不知道用哪个参数） 5.2 函数占位参数语法：返回类型 函数名（数据类型）{} //（括号里只写数据类型，传递的参数类型必须和所写的一样） void test1(int a, int) { cout &lt;&lt; \"func\" &lt;&lt; endl; } void test2(int a, int =10)//占位参数可以有默认参数 { cout &lt;&lt; \"func\" &lt;&lt; endl; } 5.3 函数重载作用：函数名可以相同，提高复用性满足条件： ①同一个作用域。（ex：都在全局作用域下） ②函数名称相同。 ③参数类型不同/个数不同/顺序不同。 //在全局作用域 void test() { cout &lt;&lt; \"调用test( )\" &lt;&lt; endl; } void test(int a) { cout &lt;&lt; \"调用test(int a)\" &lt;&lt; endl; } void test(double a) { cout &lt;&lt; \"调用test(double a)\" &lt;&lt; endl; } void test(int a, int b) { cout &lt;&lt; \"调用test(int a, int b)\" &lt;&lt; endl; } void test(int a, double b) { cout &lt;&lt; \"调用test(int a, double b)\" &lt;&lt; endl; } void test(double a, int b) { cout &lt;&lt; \"调用test(double a, int b)\" &lt;&lt; endl; } int main() { test(); test(10); test(3.14); test(10,3.14); test(3.14, 10); return 0; } 注意：函数的返回值不能作为函数重载的条件（返回值类型不同不行,有二义性）引用作为函数重载的条件 //引用作为重载条件 void test(int &amp;a) { cout &lt;&lt; \"调用test(int &amp;a)\" &lt;&lt; endl; } void test(const int&amp; b) { cout &lt;&lt; \"调用test(const int&amp; b)\" &lt;&lt; endl; } int main() { int a = 10; const int b = 10; test(a); test(b); test(10); return 0; } 函数重载碰到默认参数 //函数重载碰到默认参数 void test(int a,int b=10) { cout &lt;&lt; \"调用test(int &amp;a)\" &lt;&lt; endl; } void test(int a) { cout &lt;&lt; \"调用test(const int&amp; b)\" &lt;&lt; endl; } int main() { test(10);//err,出现二义 return 0; }","categories":[{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Co2"},{"title":"C++黑马程序员---三、内存四区","slug":"C++黑马程序员/C++黑马程序员---内存四区","date":"2022-08-06T09:00:00.000Z","updated":"2022-08-06T09:24:44.260Z","comments":true,"path":"posts/514bb67d.html","link":"","permalink":"https://cotocode.github.io/posts/514bb67d.html","excerpt":"","text":"3.1 内存四区C++程序在执行时，将内存大方向划分为4个区域： ·代码区:存放函数体的二进制代码，由操作系统进行管理的 ·全局区:存放全局变量和静态变量以及常量· 栈区:由编译器自动分配释放,存放函数的参数值,局部变量等· 堆区:由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收内存四区意义: 不同区域存放的数据，赋予不同的生命周期,给我们更大的灵活编程程序运行前： 代码区：存放函数体的的二进制代码，操作系统管理。 特点： ①共享 ：对于频繁被执行的程序，只需要在内存中有一份代码即可。 ②只读：目的是防止程序意外地修改了它的指令。 全局区：存放全局变量、静态变量（stati关键字）和常量（字符串常量和const修饰的全局变量（全局常量））。不在全局区中：局部变量、const修饰的局部变量（局部常量） //全局变量 int g_a = 10; const int c_g_a = 10; int main() { int l_a = 10; //静态变量 static int s_a = 10; //常量：字符串常量/const修饰的变量（全局/局部变量） const char* a = \"hello\"; const int c_l_a = 10; cout &lt;&lt; \"局部变量l_a的十进制地址为：\" &lt;&lt; (int)&amp;l_a &lt;&lt; endl; cout &lt;&lt; \"全局变量g_a的十进制地址为：\" &lt;&lt; (int)&amp;g_a &lt;&lt; endl; cout &lt;&lt; \"静态变量s_a的十进制地址为：\" &lt;&lt; (int)&amp;s_a &lt;&lt; endl; cout &lt;&lt; \"字符串常量a的十进制地址为：\" &lt;&lt; (int)a &lt;&lt; endl; cout &lt;&lt; \"const修饰的全局变量c_g_a的十进制地址为：\" &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl; cout &lt;&lt; \"const修饰的局部变量c_l_a的十进制地址为：\" &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl; return 0; } 程序运行后： 栈区：存放函数的参数值、局部变量。由编译器自动分配和释放。 注意事项：不要返回局部变量地址 形参数据也会放在栈区 int* funcation() { int a = 10;//存放在栈区，栈区的数据在函数执行完后自动释放 return &amp;a; } int main() { int* p = funcation(); cout &lt;&lt;\"局部变量a的值为：\"&lt;&lt; *p &lt;&lt; endl; //第一次正常打印，因为编译器做了保留 cout &lt;&lt; \"局部变量a的值为：\" &lt;&lt; *p &lt;&lt; endl; return 0; } 堆区：由程序员分配（new）和释放（delete），若程序员不释放，程序结束时由操作系统回收。 int* funcation() { //new关键字，可以将数据开辟到堆区上 //指针本质上也是局部变量，存放在栈区上，但是保存的数据在堆区 int* p = new int(10); //返回的是地址，不是数据 return p; } int main() { int* p = funcation(); cout &lt;&lt; *p &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; return 0; } 在c++中主要利用new在堆区开辟内存 3.2 new操作符 //new的基本用法 int* p = new int(10);//在堆区创建整型变量，返回该变量的地址 delete p;//释放 int* parr = new int[10];//在堆区创建一个元素为10的整型数组，返回数组首元素的地址 delete[] arr;//释放一个数组 在堆区利用new开辟数组 int * arr= new int[10]; for(int i=0;i&lt;10;i++) { arr[i]=i+100; } 释放堆区数组 delete[] arr;","categories":[{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Co2"},{"title":"C++黑马程序员---四、引用","slug":"C++黑马程序员/C++黑马程序员---引用","date":"2022-08-06T09:00:00.000Z","updated":"2022-08-06T09:32:41.706Z","comments":true,"path":"posts/b0d196a3.html","link":"","permalink":"https://cotocode.github.io/posts/b0d196a3.html","excerpt":"","text":"4.1 引用的基本使用引用：给变量起个别名。语法：数据类型 &amp; 别名=原名 int a=10; int &amp;b=a; 4.2 引用的注意事项1.引用必须要初始化2.引用一旦初始化后就不可以更改 int a = 10; int&amp; b = a; int c = 20; b = c; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; //int&amp; b = c; //错了！！！ 4.3 引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参。优点：可以简化指针修改实参 //地址传递 void swap01(int* a, int* b) { int temp = *a; *a = *b; *b = temp; } //引用传递 void swap02(int&amp; a, int&amp; b) { int temp = a; a = b; b = temp; } 4.4 引用做函数的返回值注意：不要返回局部变量的引用，函数的调用可以作为左值。（局部变量存放在栈区，函数执行完后自动释放局部变量，可以加上static是数据存放在全局区，就可以返回了） //eg. //①不要返回局部变量的引用 int&amp; test1() { int a = 10; return a; } int main() { int&amp; ret = test1(); cout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl; test1() = 20; //②如果函数的返回值为引用，函数的调用可以作为左值 cout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl; cout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl; return 0; } 4.5 引用的本质本质：引用的本质在c++内部实现是一个指针常量（指针的指向不可以修改，指针指向的值可以修改），即 引用的本质就是一个指针常量，引用一旦初始化后就不可发生改变 int&amp; ref = a; //自动转换为 int* const ref = &amp;a;指针常量是指针指向不可改，也说明为什么引用不可改 4.6 常量引用常量引用主要用来修饰形参，防止误操作。（防止修改了形参引起了实参的改变，加上const之后，修改操作会报错，不能修改） int &amp;ret=10; //错了！，引用本身需要一个合法的内存空间。 /* 相当于编译器先创建一个临时变量:int temp=10; 然后进行起别名:int&amp; ret=temp; */ const int&amp; ret = 10; 注意：用常量引用之后不可以更改数据。 //eg. int main() { const int&amp; ret = 10; ret = 100;//err cout &lt;&lt; \"ret=\" &lt;&lt; ret &lt;&lt; endl; return 0; }","categories":[{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++黑马程序员---七、文件操作","slug":"C++黑马程序员/C++黑马程序员---文件操作","date":"2022-08-06T09:00:00.000Z","updated":"2022-08-06T10:25:39.414Z","comments":true,"path":"posts/7d980d74.html","link":"","permalink":"https://cotocode.github.io/posts/7d980d74.html","excerpt":"","text":"C++中对文件操作需要包含头文件文件类型分为两种：文本文件：文件以文本的ASCII码形式存储在计算机中。二进制文件：文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂他们。操作文件三大类：ofstream：写操作ifstream：读操作fstream：读写操作 7.1 文本文件7.1.1 写文件写文件的步骤：包含头文件 #include创建流对象 ofstream ofs;打开文件 ofs.open(“文件路径”,打开方式);写数据 ofs&lt;&lt;”写入的数据”;关闭文件 ofs.close(); 打开方式 解释 ios::in 为读文件而打开文件 ios::out 为写文件而打开文件 ios::ate 初始位置：文件尾 ios::app 追加方式写文件 ios::trunc 如果文件存在先删除，再创建 ios::binary 二进制方式 文件打开方式可以配合使用，利用 | 操作符。 void test01() { ofstream ofs; ofs.open(\"test.txt\", ios::out); ofs &lt;&lt; \"姓名：张三\" &lt;&lt; endl; ofs.close(); } 7.1.2 读文件读文件的步骤：包含头文件 #include创建流对象 ifstream ifs;打开文件 ifs.open(“文件路径”,打开方式);读数据 四种读取方式关闭文件 ifs.close(); void test01() { ifstream ifs; ifs.open(\"test.txt\", ios::in); if (!ifs.is_open()) { cout &lt;&lt; \"打开失败\" &lt;&lt; endl; return; } //读数据,第一种 char buf1[1024] = { 0 }; while (ifs &gt;&gt; buf1) { cout &lt;&lt; buf1 &lt;&lt; endl; } //读数据,第二种 char buf2[1024] = { 0 }; while (ifs.getline(buf2, sizeof(buf2))) { cout &lt;&lt; buf2 &lt;&lt; endl; } //读数据,第三种 string buf3; while (getline(ifs, buf3)) { cout &lt;&lt; buf3 &lt;&lt; endl; } //读数据,第四种 char c; while ((c = ifs.get()) != EOF) { cout &lt;&lt; c; } ifs.close(); } 7.2 二进制文件打开方式要指定为 ios::binary 7.2.1 写文件二进制方式写文件主要利用流对象调用成员函数write函数原型 ：ostream&amp; write(const char * buffer,int len);参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数两种打开文件方式均可。 class Person { public: char m_Name[64]; int m_Age; }; void test01() { //1、包含头文件 //2、创建输出流对象 ofstream ofs(\"person.txt\", ios::out | ios::binary); //3、打开文件 //ofs.open(\"person.txt\", ios::out | ios::binary); Person p = { \"张三\" , 18 }; //4、写文件 ofs.write((const char*)&amp;p, sizeof(p)); //5、关闭文件 ofs.close(); }= 7.2.2 读文件二进制方式读文件主要利用流对象调用成员函数read函数原型：istream&amp; read(char *buffer,int len);参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数 class Person { public: char m_Name[64]; int m_Age; }; //二进制文件，读文件 void test01() { //1.包含头文件 //2.创建流对象 //3.打开文件并判断文件是否打开成功 ifstream ifs(\"person.txt\", ios::in | ios::binary); if (!ifs.is_open()) { cout &lt;&lt; \"文件打开失败\" &lt;&lt; endl; return; } //4.读文件(读到的是正常的不是乱码) Person p; ifs.read((char*)&amp;p, sizeof(p)); cout &lt;&lt; \"姓名： \" &lt;&lt; p.m_Name &lt;&lt; \" 年龄： \" &lt;&lt; p.m_Age &lt;&lt; endl; //5.关闭文件 ifs.close(); }","categories":[{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"C++黑马程序员---一、指针","slug":"C++黑马程序员/C++黑马程序员---指针","date":"2022-08-06T09:00:00.000Z","updated":"2022-08-06T09:13:35.961Z","comments":true,"path":"posts/514bb67d.html","link":"","permalink":"https://cotocode.github.io/posts/514bb67d.html","excerpt":"","text":"1.1 指针定义语法数据类型 * 指针变量名 int a; int * p; p = &amp;a; 1.2 使用指针可以通过解引用的方式来找到指针指向的内存。指针前加 * 代表解引用，找到指针指向的内存中的数据。 1.3 占用空间在32位操作系统下：占用四个字节空间在64位操作系统下：占用八个字节空间 1.4 空指针和野指针空指针用于给指针变量进行初始化空指针是不可以进行访问的野指针：指针变量指向非法的内存空间空指针和野指针都不是我们申请的空间，因此不要随意访问。 1.5 const修饰指针和常量const修饰指针——常量指针指针的指向可以修改，但是指针指向的指不可以改。const int * p=&amp;a; const修饰常量——指针常量指针的指向不可以改，但是指针指向的值可以改。int * const p=&amp;a; const即修饰指针又修饰常量指针的指向和指针指向的值都不可以改。const int * const p=&amp;a; 1.6 指针和数组int main() { //指针和数组 //利用指针访问数组中的元素 int arr[10] = { 1,2,3,4,5,6,7,8,9,10 }; cout &lt;&lt; \"第一个元素为:\" &lt;&lt; arr[0] &lt;&lt; endl; int* p = arr; / /arr就是数组首地址 cout &lt;&lt; \"利用指针访问第一个元素:\" &lt;&lt; *p &lt;&lt; endl; p++;//让指针向后偏移4个字节 cout &lt;&lt; \"利用指针访问第二个元素:\" &lt;&lt; *p &lt;&lt; endlsm } cout &lt;&lt; ”利用指针遍历数组\"&lt;&lt;endl; int* p2 = arr; for (int i = 0; i &lt; 10; i++) { //cout &lt;&lt; arr[i] &lt;&lt; endl; cout&lt;&lt;*p2&lt;&lt; end1; p2++; } 1.7 指针和函数值传递 void swap01(int a,int b) 地址传递 void swap02(int *p1,int *p2)","categories":[{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Co2"},{"title":"C++黑马程序员---六、类和对象","slug":"C++黑马程序员/C++黑马程序员---类和对象","date":"2022-08-06T09:00:00.000Z","updated":"2022-08-06T10:24:20.754Z","comments":true,"path":"posts/556cafdf.html","link":"","permalink":"https://cotocode.github.io/posts/556cafdf.html","excerpt":"","text":"c++面向对象三大特性：封装、继承、多态。 6.1 封装6.1.1 封装的意义 将属性和行为作为一个整体。(放在一个class里面) 将属性和行为加以权限控制。 public公共权限：类内外都可以访问 protected保护权限： 类外不可以访问 private私有权限： 类外不可以访问 //定义一个圆类 #define PI 3.14 //class 定义一个类 circle是类的名字 class circle { //访问权限：公共权限 public: //属性 int r; //行为 double circumference( ) { return r * PI * 2; } }; int main() { circle c1;//创建具体的圆（对象）（实例化） c1.r = 10;//给具体的圆的属性赋值 cout &lt;&lt; \"圆的周长为:\" &lt;&lt; c1.circumference() &lt;&lt; endl; return 0; } 6.1.2 struct和class的区别struct默认权限为： 共有 publicclass默认权限为： 私有 private 6.1.3 将成员属性设为私有优点：①将成员属性设为私有，可以自己控制读写的权限。②对于写权限，可以检测数据的有效性。 class person { private: string name;//可读写 int age;//只读 string lover;//只写 public: void SetName(string s) { name = s; } string GetName() { return name; } int GetAge() { age = 18; return age; } void SetLover(string s) { lover = s; } }; int main() { person p1; p1.SetName(\"xiyang\"); p1.SetLover(\"2A\"); cout &lt;&lt; \"姓名为：\" &lt;&lt; p1.GetName() &lt;&lt; endl; cout &lt;&lt; \"年龄为：\" &lt;&lt; p1.GetAge() &lt;&lt; endl; return 0; } 设计案例1：立方体类/* 要求： 1.设计一个立方体类 2.求出立方体的面积和体积 3.分别用全局函数和成员函数判断两个立方体是否相等 */ class cube { private: //属性 int L; int W; int H; public: //行为 //设置 获取长，宽，高 void SetL(int a) { L = a; } int GetL() { return L; } void SetW(int a) { W = a; } int GetW() { return W; } void SetH(int a) { H = a; } int GetH() { return H; } //获得面积 int S() { return 2 * ((L * W) + (L * H) + (W * H)); } //获得体积 int V() { return L * W * H; } //成员函数判断 bool isSameByClass(cube&amp; c) { if (c.GetL() == L &amp;&amp; c.GetW() ==W &amp;&amp; c.GetH() == H) return true; else return false; } }; //全局函数判断 bool isSame(cube&amp; c1, cube&amp; c2) { if (c1.GetL() == c2.GetL() &amp;&amp; c1.GetW() == c2.GetW() &amp;&amp; c1.GetH() == c2.GetH()) return true; else return false; } int main() { cube c1,c2; c1.SetL(10); c1.SetW(10); c1.SetH(10); c2.SetL(10); c2.SetW(10); c2.SetH(10); cout &lt;&lt; \"第一个立方体的面积为：\" &lt;&lt; c1.S() &lt;&lt; endl; cout &lt;&lt; \"第一个立方体的体积为：\" &lt;&lt; c1.V() &lt;&lt; endl; bool ret1 = isSame(c1, c2); if (ret1) { cout &lt;&lt; \"全局函数判断c1 c2相等\" &lt;&lt; endl; } else cout &lt;&lt; \"全局函数判断c1 c2不相等\" &lt;&lt; endl; bool ret2 = c1.isSameByClass(c2); if (ret2) { cout &lt;&lt; \"成员函数判断c1 c2相等\" &lt;&lt; endl; } else cout &lt;&lt; \"成员函数判断c1 c2不相等\" &lt;&lt; endl; return 0; } 设计案例2：点和圆的关系源.cpp #include&lt;iostream&gt; using namespace std; #include\"point.h\" #include\"circle.h\" void IsInCircle(Circle &amp;c,Point &amp;p) { int distance = (c.getCenter().getX() - p.getX()) * (c.getCenter().getX() - p.getX()) + (c.getCenter().getY() - p.getY()) * (c.getCenter().getY() - p.getY()); int rdistance = c.getR() * c.getR(); if (distance == rdistance) cout &lt;&lt; \"点在圆上\"&lt;&lt;endl; else if (distance &gt; rdistance) cout &lt;&lt; \"点在圆外\"&lt;&lt;endl; else cout &lt;&lt; \"点在圆内\"&lt;&lt;endl; } int main() { Circle c; Point center; Point q; center.setX(10); center.setY(10); q.setX(10); q.setY(10); c.setCenter(center); c.setR(10); IsInCircle(c, q); return 0; } circle.h #pragma once #include&lt;iostream&gt; using namespace std; #include\"point.h\" class Circle { public: void setR(int r); int getR(); void setCenter(Point center); Point getCenter(); private: int m_R; Point m_Center; }; circle.cpp #include\"circle.h\" void Circle::setR(int r) { m_R = r; } int Circle::getR() { return m_R; } void Circle::setCenter(Point center) { m_Center = center; } Point Circle::getCenter() { return m_Center; } point.h #pragma once #include&lt;iostream&gt; using namespace std; class Point { public: void setX(int x); int getX(); void setY(int y); int getY(); private: int m_X;//д int m_Y;//д }; point.cpp #include\"point.h\" void Point::setX(int x) { m_X = x; } int Point::getX() { return m_X; } void Point::setY(int y) { m_Y = y; } int Point::getY() { return m_Y; } 6.2 对象的初始化和清理C++利用构造函数和析构函数解决了对象的初始化和清理。对象的初始化和清理工作是编译器强制要求我们做的事情，因此就算我们不提供构造和析构，编译器也会提供，只不过编译器提供的是构造函数和析构函数的空实现。 6.2.1 构造函数定义：主要作用在创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。语法：类名 () { }注意：①没有返回值，不用写void。 ②函数名与类名相同。 ③构造函数可以有参数，可以发生重载。 ④创建对象时，构造函数会自动调用，并且只调用一次。分类：按参数分类：有参构造和无参构造（默认构造）按类型分类：普通构造和拷贝构造调用方式：括号法、显示法、隐式转换法 //构造的分类和调用 class person { public: //无参（普通构造）（默认构造） person() { cout &lt;&lt; \"无参构造函数调用\" &lt;&lt; endl; } //有参（普通构造） person(int a) { age = a; cout &lt;&lt; \"有参构造函数调用\" &lt;&lt; endl; } //拷贝构造函数 person(const person&amp; p) //加const作用，拷贝之后防止本体被修改 { age = p.age;//克隆数据 cout &lt;&lt; \"拷贝构造函数的调用\" &lt;&lt; endl; } int age; }; int main() { //括号法 person p1;//不能加(),加了()编译器会认为是一个函数声明，在一个函数体里可以声明另一个函数 person p2(10); //p2的年龄初始化为10 person p3(p2); //显示法 person p4 = person(); person p5 = person(10); person p6 = person(p5); //person()为匿名对象，没有名字，但创建了对象，特点：当前行执行结束后系统就会回收掉匿名对象 //不要用拷贝构造函数初始化匿名对象，如person(p3)，等价于person p3 //隐式转换法 person p7 = 10;//转换为：person p7=person(10) } 6.2.2 析构函数定义：主要作用在于对象销毁前系统自动调用，执行一些清理工作。语法：~类名 () { }注意：①没有返回值，不写void②函数名和类名相同，在名称前加~③析构函数不可以有参数，不可以发生重载④对象在销毁前会自动调用析构函数，并且只会调用一次 //构造函数和析构函数例子 class person { public: person() { cout &lt;&lt; \"构造函数的调用\" &lt;&lt; endl; } ~person() { cout &lt;&lt; \"析构函数的调用\" &lt;&lt; endl; } }; void test() { person P; } int main() { test(); return 0; } 6.2.3 拷贝构造函数调用时机C++中拷贝函数调用一般有三种情况： ①使用一个已创建完毕的对象来初始化一个新对象。 ②值传递的方式给函数参数传值。 ③以值的方式返回局部对象。 class person { public: person() { cout &lt;&lt; \"默认构造函数的调用\" &lt;&lt; endl; } person(int a) { age = a; cout &lt;&lt; \"默认构造函数的调用\" &lt;&lt; endl; } person(const person&amp; p) { age = p.age;//克隆数据 cout &lt;&lt; \"拷贝构造函数的调用\" &lt;&lt; endl; } int show() { return age; } private: int age; }; void test1(person p) { } person test2() { person p; return p; } int main() { //使用一个已创建完毕的对象来初始化一个新对象 person p1(20); person p2(p1); cout &lt;&lt; \"p2的年龄为：\" &lt;&lt; p2.show() &lt;&lt; endl; //值传递的方式给函数参数传值,拷贝一份临时副本作为形参，改变临时副本的值不影响实参 person p3; test1(p3); //以值的方式返回局部对象，return返回时返回的不是局部对象，而是拷贝一个新对象返回 test2(); return 0; } 6.2.4 构造函数调用规则创建一个类，C++至少给每一个类添加4个函数：1、默认构造(空实现)2、析构函数(空实现)3、拷贝构造(值拷贝)4、赋值运算符Operator=对属性进行值拷贝①如果用户定义一个有参构造函数，C++不会提供默认构造函数，但是会提供拷贝构造函数。②如果用户定义一个拷贝构造函数，C++不会提供别的构造函数。 //eg.①如果用户定义一个有参构造函数，C++不会提供默认构造函数，但是会提供拷贝构造函数 class person { public: person(int a) { age = a; cout &lt;&lt; \"默认构造函数的调用\" &lt;&lt; endl; } int show() { return age; } private: int age; }; int main() { person p1;//err person p2(18); person p3(p2);//拷贝构造函数 cout &lt;&lt; \"p2的年龄为：\" &lt;&lt; p2.show() &lt;&lt; endl; return 0; } 6.2.5 深拷贝与浅拷贝浅拷贝：简单的赋值拷贝。深拷贝：在堆区重新申请空间，进行拷贝。浅拷贝存在的问题：属性有在堆区开辟的，拷贝之后两个类成员堆区属性都指向同一个地址，新拷贝成员执行析构操作之后，堆区内存被释放，旧成员执行析构操作就会使堆区内容重复释放。 解决方法：使两个成员堆区内容指向不同的地址，即进行深拷贝。 class person { public: person(int a, int h) { age = a; height = new int(h); cout &lt;&lt; \"有参构造函数的调用\" &lt;&lt; endl; } person(const person&amp; p) { age = p.age; //height=p.height;//编译器默认实现 height = new int(*(p.height)); cout &lt;&lt; \"拷贝构造函数的调用\" &lt;&lt; endl; } ~person() { if (height != NULL) { delete height; height = NULL; } cout &lt;&lt; \"析构函数的调用\" &lt;&lt; endl; } int GetAge() { return age; } int GetHeight() { return *height; } private: int age; int* height; }; int main() { person p1(18, 160); cout &lt;&lt; \"p1的年龄为：\" &lt;&lt; p1.GetAge() &lt;&lt; \" p1的身高为：\" &lt;&lt; p1.GetHeight() &lt;&lt; endl; person p2(p1); cout &lt;&lt; \"p2的年龄为：\" &lt;&lt; p2.GetAge() &lt;&lt; \" p2的身高为：\" &lt;&lt; p2.GetHeight() &lt;&lt; endl; return 0; } 6.2.6 初始化列表作用： 用来初始化属性。语法： 构造函数（）：属性1（值1），属性2（值2）…{} class person { public: //初始化列表初始化属性 person() :age(10), weigh(123), height(160) { } person(int a, int b, int c) :age(a), weigh(b), height(c) { } int age; int weigh; int height; }; int main() { person p1; person p2(18, 456, 180); cout &lt;&lt; \"p1的年龄，体重，身高为：\\n\" &lt;&lt; p1.age &lt;&lt; p1.weigh &lt;&lt; p1.height&lt;&lt;endl; cout &lt;&lt; \"p2的年龄，体重，身高为：\\n\" &lt;&lt; p2.age &lt;&lt; p2.weigh &lt;&lt; p2.height&lt;&lt;endl; return 0; } 6.2.7 类对象作为类的成员注意：当其他类对象作为本类成员，构造时先构造类对象，再构造自身。析构顺序和构造顺序相反。 class Phone { public: Phone(string name) :PhoneName(name) { } string PhoneName; }; class Person { public: Person(string s, string p) :PersonName(s),PhoneName(p) { } string PersonName; string PhoneName; }; int main() { Person p(\"gua\", \"iphone\"); cout &lt;&lt; p.PersonName &lt;&lt; endl&lt;&lt;p.PhoneName &lt;&lt; endl; return 0; } 6.2.8 静态成员静态成员就是在成员变量和成员函数前加上关键字static。静态成员变量： 所有对象共享一份数据。 在编译阶段分配内存（运行之前就分配了）。 类内声明，类外初始化。 class Person { public: static int a;//类内声明 }; int Person::a = 100;//类外初始化 int main() { Person p1; cout &lt;&lt; \"a的值为：\" &lt;&lt; p1.a &lt;&lt; endl; Person p2; p2.a = 200; cout &lt;&lt; \"a的值为：\" &lt;&lt; p1.a &lt;&lt; endl; return 0; } ** 注意：**静态成员变量不属于某一个对象。因此有两种访问方式：①类名访问，②对象访问。 class Person { public: static int a; }; int Person::a = 100; int main() { //对象访问 Person p1; cout &lt;&lt; p1.a &lt;&lt; endl; //类名访问 cout &lt;&lt; Person::a &lt;&lt; endl; return 0; } 静态成员变量也有访问权限(类外访问不到私有静态成员变量)。静态成员函数：所有对象共享一个函数。静态成员函数只能访问静态成员变量(访问成员变量，函数无法区分是哪个对象的成员变量)。静态成员函数也有两种访问方式： //静态成员函数的访问 class Person { public: static void test() { cout &lt;&lt; \"static void test()调用\" &lt;&lt; endl; } }; int main() { //对象访问 Person p; p.test(); //成员访问 Person::test(); return 0; } //静态成员函数只能访问静态成员函数 class Person { public: static void test() { a = 200; b = 200;//err，对象不明 cout &lt;&lt; \"static void test()调用\" &lt;&lt; endl; } static int a;//静态成员函数访问静态成员变量 int b;//非静态成员函数 }; int Person::a = 100; int main() { Person p; p.test(); return 0; } 静态成员函数也有访问权限（类外访问不到私有静态成员函数）。 6.3 C++对象模型和this指针6.3.1 成员变量和成员函数分开存储在C++中，类的成员变量和成员函数分开存储，只有非静态成员变量才属于类的对象上。 class person1 { }; class person2 { int a;//非静态成员变量 }; class person3 { int a; static int b;//静态成员变量 }; class person4 { int a; static int b;//静态成员变量 void test()//非静态成员函数 { } }; int main() { //空对象占用内存是 1 //C++会给每一个空对象分配一个字节的内存空间，为了区分空对象占内存的位置 //每一个空对象也应该有一个独一无二的内存地址 person1 p1; cout &lt;&lt; \"sizeof(p)=\" &lt;&lt; sizeof(p1) &lt;&lt; endl;//1 //虽然空对象有一个字节，但是一旦类里面不为空就跟着类中字节走 person2 p2; cout &lt;&lt; \"sizeof(p)=\" &lt;&lt; sizeof(p2) &lt;&lt; endl;//4 //静态成员变量不属于类对象上的 person3 p3; cout &lt;&lt; \"sizeof(p)=\" &lt;&lt; sizeof(p3) &lt;&lt; endl;//4 //类的成员变量和成员函数分开存储 person4 p4; cout &lt;&lt; \"sizeof(p)=\" &lt;&lt; sizeof(p4) &lt;&lt; endl;//4 return 0; } 6.3.2 this指针的概念this指针指向被调用的成员函数所属的对象。this指针隐含在每一个非静态成员函数内的一种指针。this指针不需要定义，可直接使用。this指针的用途： 当形参和成员变量同名时，可以用this指针来区分。（解决名称冲突） 在类的非静态成员函数中返回对象本身，可以用retrun this（返回对象本身用 *this）形参与成员变量名称相同时，无法进行赋值，利用this指针解决* 在类的非静态成员函数中返回对象本身，可以用retrun *this** class person { public: person(int age) { this-&gt;age = age; } person&amp; test(person p)//person一定要加&amp;，使用本体 { this-&gt;age += p.age; return *this; } int age; }; int main() { person p1(18); person p2(18); //链式编程 p2.test(p1).test(p1); cout &lt;&lt; \"p2的年龄为：\" &lt;&lt; p2.age &lt;&lt; endl; return 0; } 如果不加引用，每次返回的都是拷贝构造函数构造的新的对象，和原来不一样，要多次连续对一个对象操作，需要加上引用。 6.3.3 空指针访问成员函数C++中空指针可以调用成员函数，但要注意有没有用到this指针。如果用到this指针，需要加以判断保证代码的健壮性。 class person { public: void test1() { cout &lt;&lt; \"test1\" &lt;&lt; endl; } void test2() { cout &lt;&lt; \"age=\"&lt;&lt;age&lt;&lt; endl; //age相当于this-&gt;age } int age; }; int main() { person *p=NULL; p-&gt;test1(); p-&gt;test2(); //err，传入的指针为空 return 0; } ** 改正方法：** void test2() { if(this-&gt;age==NULL) return;//提高代码的健壮性 cout &lt;&lt; \"age=\"&lt;&lt;this-&gt;age&lt;&lt; endl;//err，传入的指针为空 } 6.3.4 const修饰成员函数const,限制为只读状态。常函数：（成员函数后加const）常函数内不可以修改成员属性。 成员属性声明时加关键字mutable后，在常函数中依然可以修改。函数中this指针的定义相当于 Person * const this，指针的指向不可以修改，但指针指向的值可以修改。常函数中this指针的定义相当于const Person * const this，指针的指向和指针指向的值均不可修改。 class person { void test2() { a = 100; b = 200; //err b是常量不可以修改 c = 300; } //在成员函数后加const，修饰的是this指向，让指针指向的值不能改变 void test1() const { a = 100; //err 相当于this-&gt;a=100 b = 200; //err b是常量不可修改 c = 300; } int a; const int b; mutable int c; }; int main() { person p; p.test1(); p.test2(); return 0; } 常对象：（声明对象前加const）常对象只能调用常函数。（常对象本身不允许修改对象属性，如果常对象调用的常函数对对象属性进行了修改，相当于间接的对常对象的属性进行了修改，所以常对象只能调用不能对对象属性进行修改的函数即常函数）常对象可以修改声明时加关键字mutable的成员属性。 class person { public: void test1() { } void test2() const { } int a; const int b; mutable int c; }; int main() { const person p;//不能修改指针指向的值 p.a = 100;//err p.b = 200;//err p.c = 300; p.test1();//err 常对象只能调用常函数 p.test2(); } 6.4 友元友元的目的就是让一个函数或者类访问另一个类中的私有成员。在 private 和 public 中声明均可。 6.4.1 全局函数做友元//全局函数做友元 class building { private: string bedroom; friend void test2(building* b);//声明友元函数 public: building() { bedroom = \"卧室\"; livingroom = \"客厅\"; } string livingroom; }; void test1(building* b) { cout &lt;&lt; \"访问\" &lt;&lt; b-&gt;livingroom &lt;&lt; endl; //cout &lt;&lt; \"访问\" &lt;&lt; b-&gt;bedroom &lt;&lt; endl;//err 不可访问私有成员 } void test2(building* b) { cout &lt;&lt; \"访问\" &lt;&lt; b-&gt;livingroom &lt;&lt; endl; cout &lt;&lt; \"访问\" &lt;&lt; b-&gt;bedroom &lt;&lt; endl; } 6.4.2 类做友元//类做友元 class Building { friend class GoodGay2; public: Building(); string Livingroom; private: string Bedroom; }; class GoodGay1 { public: GoodGay1(); void visit(); Building* p; }; class GoodGay2 { public: GoodGay2(); void visit(); Building* p; }; Building::Building() { Bedroom = \"卧室\"; Livingroom = \"客厅\"; } //非友元 GoodGay1::GoodGay1() { p = new Building; } void GoodGay1::visit() { cout &lt;&lt; \"朋友在访问\" &lt;&lt; p-&gt;Livingroom &lt;&lt; endl; cout &lt;&lt; \"朋友在访问\" &lt;&lt; p-&gt;Bedroom &lt;&lt; endl;//err 没有访问权限 } //友元 GoodGay2::GoodGay2() { p = new Building; } void GoodGay2::visit() { cout &lt;&lt; \"朋友在访问\" &lt;&lt; p-&gt;Livingroom &lt;&lt; endl; cout &lt;&lt; \"朋友在访问\" &lt;&lt; p-&gt;Bedroom &lt;&lt; endl; } int main() { GoodGay1 g1; g1.visit(); GoodGay2 g2; g2.visit(); return 0; } 6.4.3 成员函数做友元class Building;//当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。 class GoodGay { public: GoodGay(); void visit1(); void visit2(); Building* building; }; class Building { public: friend void GoodGay::visit1(); Building(); public: string LivingRoom; private: string BedRoom; }; Building::Building() { LivingRoom = \"客厅\"; BedRoom = \"卧室\"; } GoodGay::GoodGay() { building = new Building; } void GoodGay::visit1() { cout &lt;&lt; \"visit函数正在访问：\" &lt;&lt; building-&gt;LivingRoom &lt;&lt; endl; cout &lt;&lt; \"visit函数正在访问：\" &lt;&lt; building-&gt;BedRoom &lt;&lt; endl; } void GoodGay::visit2() { cout &lt;&lt; \"visit函数正在访问：\" &lt;&lt; building-&gt;LivingRoom &lt;&lt; endl; cout &lt;&lt; \"visit函数正在访问：\" &lt;&lt; building-&gt;BedRoom &lt;&lt; endl; } void test1() { GoodGay gg; gg.visit1(); } void test2() { GoodGay gg; gg.visit2(); } int main() { test1(); test2(); } 6.5 运算符重载运算符重载对已有的运算符重新定义，赋予另一种功能，以适应不同的数据类型。对内置的数据类型，编译器知道如何进行运算，对非内置的数据类型就需要对运算符进行重载。 6.5.1 加号运算符重载class Person { public: //成员函数实现+重载 Person operator+(Person&amp; p) { Person temp; temp.m_A = this-&gt;m_A + p.m_A; temp.m_B = this-&gt;m_B + p.m_B; return temp; } int m_A; int m_B; }; //全局函数实现+重载 Person operator+(Person&amp; p1, Person&amp; p2) { Person temp; temp.m_A = p1.m_A + p2.m_A; temp.m_B = p1.m_B + p2.m_B; return temp; } void test01() { Person p1; p1.m_A = 10; p1.m_B = 10; Person p2; p2.m_A = 10; p2.m_B = 10; Person p3 = p1 + p2; cout &lt;&lt; p3.m_A &lt;&lt; endl &lt;&lt; p3.m_B &lt;&lt; endl; } 运算符重载也可以发生函数重载。对于内置的数据类型的表达式的运算符是不可能改变的。不要滥用运算符重载。（加法写成减法，减法写成乘法，别人可能看不懂代码） 6.5.2 左移运算符（&lt;&lt;）的重载作用：可以输出自定义的数据类型。加&amp;的原因：输入 ostream&amp; cout带&amp;的原因是因为输出流对象cout全局只能有一个，不能创建一个新的传进来，要带引用。写成：ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p)，则：cout&lt;&lt;a&lt;&lt;b;正确，因为它等同于(cout&lt;&lt;a)&lt;&lt;b;(cout&lt;&lt;a)返回cout的引用，即就是它自己，它可以再次作为左值，因而能够连着写这个输出流 。如果不加&amp; 第一个括号中返回的是cout的临时变量，它不可作为左值（因为operator &lt;&lt; (ostream&amp; cout, Person&amp; p)的第一个参数是ostream&amp;，而不是ostream），因而错误。 class Person { friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Person&amp; p); public: //舍弃成员函数重载，简化为p.operator&lt;&lt;cout，相当于p&lt;&lt;cout //void operator&lt;&lt;(cout) //{ //} Person() { this-&gt;m_a = 10; this-&gt;m_b = 10; } private: int m_a; int m_b; }; //全局函数重载左移运算符 //返回ostream是链式编程思想，返回后cout&lt;&lt;p&lt;&lt;...后面可以再利用 ostream&amp; operator&lt;&lt;(ostream&amp; cout,Person&amp; p) { cout &lt;&lt; p.m_a &lt;&lt; endl &lt;&lt; p.m_b &lt;&lt; endl; return cout; } 6.5.3 递增运算符的重载作用：通过重载递增运算符，实现自己的整型数据。重载 &lt;&lt; 时 Intege r加 &amp; 后输出 myint++ 报错，不加 &amp; 不会报错。原因：后置++不是一个可修改的左值，非常量引用必须是一个可修改的左值。 class Integer { friend ostream&amp; operator&lt;&lt;(ostream&amp; cout, Integer p); private: int num; public: Integer() { this-&gt;num = 0; } //前置++ //&amp;的作用是对同一个数据进行递增 Integer&amp; operator++() { //先++ this-&gt;num++; //再返回 return *this; } //后置++ //int是占位参数 Integer operator++(int) { //先暂存 Integer temp=*this; //再++ num++; //返回暂存的数据 return temp; } }; ostream&amp; operator&lt;&lt;(ostream&amp; cout, Integer p) { cout &lt;&lt; p.num; return cout; } void test01() { Integer myint; cout &lt;&lt; ++myint &lt;&lt; endl; cout &lt;&lt; myint &lt;&lt; endl; } void test02() { Integer myint; cout &lt;&lt; myint++&lt;&lt;endl; cout &lt;&lt; myint &lt;&lt; endl; } 6.5.4 赋值运算符重载创建一个类，C++ 至少给每一个类添加4个函数：默认构造(空实现)，析构函数(空实现)，拷贝构造(值拷贝)，赋值运算符 operator= 对属性进行值拷贝。赋值运算符重载要注意数据存放在堆区时，浅拷贝带来的问题。 //赋值运算符的重载 class person { public: person(int a) { age=new int(a); } ~person() { if (age != NULL) { delete age; age = NULL; } } //重载赋值运算符以避免浅拷贝带来的问题 person&amp; operator=(person&amp; p) { //age=p.age;//编译器默认实现 if (age != NULL) { delete age; age = NULL; } age = new int(*p.age); //返回自身 return *this; } int *age; }; int main() { person p1(10); person p2(20); person p3(30); p3=p2 = p1; cout &lt;&lt; *(p2.age) &lt;&lt; endl;//10 cout &lt;&lt; *(p3.age) &lt;&lt; endl;//10 return 0; } 6.5.5 关系运算符的重载作用：可以让两个自定义类型对象进行对比操作。 //关系运算符重载 == != class person { public: person(string s,int a):name(s),age(a) { } bool operator==(person&amp; p) { if (this-&gt;name == p.name &amp;&amp; this-&gt;age == p.age) { return true; } else return false; } string name; int age; }; int main() { person p1(\"Tom\",10); person p2(\"Jerry\",20); if (p1 == p2) { cout &lt;&lt; \"p1和p2相等\" &lt;&lt; endl; } else cout &lt;&lt; \"p1和p2不相等\" &lt;&lt; endl; return 0; } 6.5.6 函数调用运算符()重载重载后的使用方式非常像函数调用，因此称为仿函数。仿函数没有固定写法，非常灵活。 class MyPrint { public: void operator()(string test) { cout &lt;&lt; test &lt;&lt; endl; } }; void MyPrint02(string test) { cout &lt;&lt; test &lt;&lt; endl; } void test01() { MyPrint myprint; myprint(\"Hello World!\"); //使用起来非常类似函数调用，因此称为仿函数 MyPrint02(\"Hello World!\"); } //仿函数非常灵活，没有固定的写法 //加法类 class MyAdd { public: int operator()(int num1, int num2) { return num1 + num2; } }; void test02() { MyAdd myadd; cout&lt;&lt;myadd(10, 20)&lt;&lt;endl; //匿名函数对象 cout&lt;&lt;MyAdd()(10, 20)&lt;&lt;endl; } 6.6 继承6.6.1 继承的基本语法继承的好处：减少重复代码。语法：class 子类 : 继承方式 父类{};派生类中的成员包含两部分：一类是从基类继承过来的（共性），一类是自己增加的成员（个性）。 6.6.2 继承的方式公共继承，public保护继承，protected私有继承，private 6.6.3 继承中的对象模型父类中的所有非静态成员属性都会被子类继承父类的私有成员被编译器隐藏，访问不到但是被继承 class Base { public: int a; static int d;//不继承 protected: int b; private: int c; }; class son :public Base { public: int e; }; int main() { //父类中的所有非静态成员属性都会被子类继承 //父类的私有成员被编译器隐藏，访问不到但是被继承 cout &lt;&lt; \"size of(son)=\" &lt;&lt; sizeof(son) &lt;&lt; endl;//16 return 0; } 利用工具查看：1.2. 跳转盘符3.跳转文件路径 cd 具体路径下4.查看命名 cl /d1 reportSingleClassLayout查看的类名 所属文件名 6.6.4 继承中构造和析构顺序class Base { public: Base() { cout &lt;&lt; \"父类构造\"&lt;&lt;endl; } ~Base() { cout &lt;&lt; \"父类析构\"&lt;&lt;endl; } }; class Son :public Base { public: Son() { cout &lt;&lt; \"子类构造\"&lt;&lt;endl; } ~Son() { cout &lt;&lt; \"子类析构\"&lt;&lt;endl; } }; 6.6.5 继承中同名成员的处理方式子类对象访问子类同名成员：直接访问子类对象访问父类同名成员：加作用域如果子类中出现和父类同名的成员函数，子类同名成员函数会隐藏掉父类中所有的同名成员函数（父类中同名成员函数，和同名成员函数的重载函数）。 class Base { public: Base() { m_A=100; } void func() { cout &lt;&lt; \"Base_func\"&lt;&lt;endl; } int m_A; }; class Son :public Base { public: Son() { m_A = 200; } void func() { cout &lt;&lt; \"Son_func\"&lt;&lt;endl; } int m_A; }; void test01() //同名成员属性处理 { Son son; cout &lt;&lt; son.m_A &lt;&lt; endl; cout &lt;&lt; son.Base::m_A &lt;&lt; endl; } void test02() //同名成员函数处理 { Son son; son.func(); son.Base::func(); } 6.6.6 继承同名静态成员处理方式静态成员和非静态成员出现同名时，处理方式一致。注意通过对象访问和通过类名访问两种方式。 class Base { public: static void func() { cout &lt;&lt; \"Base_func\" &lt;&lt; endl; } static int m_A; }; int Base::m_A = 100; class Son :public Base { public: static void func() { cout &lt;&lt; \"Son_func\" &lt;&lt; endl; } static int m_A; }; int Son::m_A = 200; void test01() //同名成员属性处理 { //通过对象访问 Son son; cout &lt;&lt; son.m_A &lt;&lt; endl; cout &lt;&lt; son.Base::m_A &lt;&lt; endl; //通过类名访问 cout &lt;&lt; Son::m_A &lt;&lt; endl; cout &lt;&lt; Son::Base::m_A &lt;&lt; endl; } void test02() //同名成员函数处理 { //通过对象访问 Son son; son.func(); son.Base::func(); //通过类名访问 Son::func(); Son::Base::func(); } 6.6.7 多继承语法语法：class 子类 ：继承方式 父类1，继承方式 父类2，…实际开发中不建议使用多继承。 class Base1{ public: Base1() { this-&gt;a = 100; } int a; }; class Base2 { public: Base2() { b = 200; } int b; }; class Son :public Base1, public Base2 { public: Son() { c = 300; } int c; }; 6.6.8 菱形继承两个派生类继承同一个基类，又有某个类同时继承者两个派生类。主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义，通过虚继承来解决。 class Animal { public: int age; }; class Sheep :virtual public Animal { }; class Camel :virtual public Animal { }; class SheepCamel :public Sheep, public Camel { }; void test01() { Sheep sheep; sheep.age = 18; Camel camel; camel.age = 28; SheepCamel sheepcamel; sheepcamel.age = 38; cout &lt;&lt; sheep.age &lt;&lt; endl; cout &lt;&lt; camel.age &lt;&lt; endl; cout &lt;&lt; sheepcamel.age &lt;&lt; endl; } 6.7 多态6.7.1 多态的基本概念多态可分为两类： 静态多态：函数重载 和 运算符重载动态多态：派生类和虚函数实现运行时多态两者的区别：静态多态的函数地址早绑定 - 编译阶段确定函数地址（运行前就确定了走哪一段代码）动态多态的函数地址晚绑定 - 运行阶段确定函数地址（运行起来才确定走哪一段代码） class Animal { public: virtual void speak() { cout &lt;&lt; \"动物在说话？\"; } int age; }; class Cat :public Animal { virtual void speak() { cout &lt;&lt; \"小猫在说话？\"&lt;&lt;endl; } }; class Dog :public Animal { void speak() { cout &lt;&lt; \"小狗在说话？\"&lt;&lt;endl; } }; void DoSpeak(Animal &amp;animal) { animal.speak(); } void test01() { Cat cat; Dog dog; DoSpeak(cat); DoSpeak(dog); } 动态多态满足条件:有继承关系子类重写父类中的虚函数（子类的virtual可有可无）重写：函数返回值类型，函数名，参数列表 完全一致称为重写动态多态的使用：父类的指针或引用，执行子类对象。重写后，子类的vfptable中内容会发生改写。 6.7.2 多态案例—-计算器类多态好处：组织结构清晰。可读性强。对前期和后期的扩展以及维护性高。开发中提倡开闭原则：对扩展进行开放，对修改进行关闭。C++开发提倡利用多态设计程序架构，因为多态优点很多。 //抽象计算机类 class AbstractCalculator { public: virtual int getresult() { return 0; } int num1; int num2; }; //加法计算机类 class AddCalculator :public AbstractCalculator { public: int getresult() { return num1 + num2; } }; //减法计算机类 class SubCalculator :public AbstractCalculator { public: int getresult() { return num1 - num2; } }; //乘法计算器类 class MulCalculator :public AbstractCalculator { public: int getresult() { return num1 * num2; } }; void Calculator() { //父类指针执行子类对象 AbstractCalculator* abc; //加法 abc = new AddCalculator; abc-&gt;num1 = 10; abc-&gt;num2 = 20; cout&lt;&lt;abc-&gt;getresult()&lt;&lt;endl; //减法 abc = new SubCalculator; abc-&gt;num1 = 20; abc-&gt;num2 = 10; cout &lt;&lt; abc-&gt;getresult()&lt;&lt;endl; //乘法 abc = new MulCalculator; abc-&gt;num1 = 10; abc-&gt;num2 = 20; cout &lt;&lt; abc-&gt;getresult()&lt;&lt;endl; delete abc; } 6.7.3 纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数。纯虚函数定义：virtual 返回值类型 函数名 （参数列表）= 0 ;抽象类定义：当类中有了纯虚函数，这个类也称为抽象类抽象类的特点：无法实例化对象子类必须重写抽象类中的纯虚函数，否则也属于抽象类 class Base { public: //纯虚函数 virtual void func() = 0; }; class Son1 :public Base { public: }; class Son2 :public Base { public: void func() { } }; int main() { //base b;//err 抽象类无法实例化对象 //new base;//err //son1 s;//子类必须重写抽象类中的纯虚函数，否则也属于抽象类 son2 s; } 6.7.4 多态案例二—-制作饮品class AbstructDrinking { public: //煮水 virtual void BoilWater() { cout &lt;&lt; \"煮水\" &lt;&lt; endl; } //冲泡 virtual void Brew() = 0; //倒入杯中 virtual void PourInCup() { cout &lt;&lt; \"倒入杯中\" &lt;&lt; endl; } //加入辅料 virtual void PutSomething() = 0; void makeDrink() { BoilWater(); Brew(); PourInCup(); PutSomething(); } }; class Coffee :public AbstructDrinking { public: //冲泡 virtual void Brew() { cout &lt;&lt; \"冲泡咖啡\"&lt;&lt;endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; \"加入糖和牛奶\" &lt;&lt; endl; } }; class Tea :public AbstructDrinking { public: //冲泡 virtual void Brew() { cout &lt;&lt; \"冲泡茶叶\" &lt;&lt; endl; } //加入辅料 virtual void PutSomething() { cout &lt;&lt; \"加入柠檬\" &lt;&lt; endl; } }; void DoWork(AbstructDrinking* drink) { drink-&gt;makeDrink(); delete drink; } void test01() { AbstructDrinking* drink = new Coffee; DoWork(drink); cout &lt;&lt; \"----------------------\" &lt;&lt; endl; drink = new Tea; DoWork(drink); } 6.7.5 虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构函数，出现内存泄漏。解决方式：将父类中的析构函数改为虚析构或者纯虚析构。虚析构语法：virtual ~类名(){}纯虚析构语法：virtual ~类名() = 0;类名::~类名(){} 纯虚析构函数要有具体的函数实现两者共性：都可以解决父类指针释放子类对象。都需要具体的函数实现。两者区别：如果是纯虚析构，该类属于抽象类，无法实例化对象。 class Animal { public: Animal() { cout &lt;&lt; \"Animal构造函数的调用\" &lt;&lt; endl; } ~Animal() { cout &lt;&lt; \"Animal析构函数的调用\" &lt;&lt; endl; } //虚析构可以解决 父类指针释放子类对象时不干净的问题 //virtual ~Animal() //{ // cout &lt;&lt; \"Animal虚析构函数的调用\" &lt;&lt; endl; //} //纯虚析构 //virtual ~Animal() = 0; virtual void speak() = 0; }; //纯虚析构函数要有具体的函数实现 //Animal::~Animal() //{ // cout &lt;&lt; \"Animal纯虚析构函数的调用\" &lt;&lt; endl; //} class Cat:public Animal { public: Cat(string n) { cout &lt;&lt; \"Cat的构造函数的调用\" &lt;&lt; endl; name = new string(n); } void speak() { cout &lt;&lt; *name&lt;&lt;\"miao~\" &lt;&lt; endl; } ~Cat() { cout &lt;&lt; \"Cat的析构函数的调用\" &lt;&lt; endl; if (name != NULL) { delete name; name = NULL; } } string *name; }; int main() { Animal* a = new Cat(\"mimi\"); a-&gt;speak(); //父类指针在析构时候，不会调用子类中的析构函数，导致子类如果有堆区的属性，会出现内存的泄露 delete a; } 总结：虚析构或纯虚析构就是用来解决通过父类指针释放子类对象。如果子类中没有堆区数据，可以不写为虚析构或纯虚析构。用于纯虚析构函数的类也属于抽象类 6.7.6 多态案例三—-电脑组装//抽象不同零件的类 class CPU { public: virtual void calculate() = 0; }; class VideoCard { public: virtual void display() = 0; }; class Memory { public: virtual void storage() = 0; }; //电脑类 class Computer { public: Computer(CPU* cpu, VideoCard* vc, Memory* mem) { this-&gt;cpu = cpu; this-&gt;vc = vc; this-&gt;mem = mem; } void Work() { cpu-&gt;calculate(); vc-&gt;display(); mem-&gt;storage(); } ~Computer() { if (cpu != NULL) { cout &lt;&lt; \"cpu释放\" &lt;&lt; endl; delete cpu; cpu = NULL; } if (vc != NULL) { cout &lt;&lt; \"显卡释放\" &lt;&lt; endl; delete vc; vc = NULL; } if (mem != NULL) { cout &lt;&lt; \"内存条释放\" &lt;&lt; endl; delete mem; mem = NULL; } cout &lt;&lt; \"电脑释放\" &lt;&lt; endl; } void Cpu() { cout &lt;&lt; cpu &lt;&lt; endl; } private: CPU* cpu; VideoCard* vc; Memory* mem; }; //Intel class IntelCpu :public CPU { public: virtual void calculate() { cout &lt;&lt; \"Intel的CPU开始计算了？\"&lt;&lt;endl; } }; class IntelVc :public VideoCard { public: virtual void display() { cout &lt;&lt; \"Intel的显卡开始显示了？\"&lt;&lt;endl; } }; class IntelMem :public Memory { public: virtual void storage() { cout &lt;&lt; \"Intel的内存条开始存储了？\"&lt;&lt;endl; } }; //Lenovo class LenovoCpu :public CPU { public: virtual void calculate() { cout &lt;&lt; \"Lenovo的CPU开始计算了？\"&lt;&lt;endl; } }; class LenovoVc :public VideoCard { public: virtual void display() { cout &lt;&lt; \"Lenovo的显卡开始显示了？\"&lt;&lt;endl; } }; class LenovoMem :public Memory { public: virtual void storage() { cout &lt;&lt; \"Lenovo的内存条开始存储了？\"&lt;&lt;endl; } }; void test01() { //第一台电脑零件 CPU* cpu = new IntelCpu; VideoCard* vc = new IntelVc; Memory* mem = new IntelMem; //创建第一台电脑 Computer *computer = new Computer(cpu, vc, mem); computer-&gt;Work(); delete computer; }","categories":[{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Co2"},{"title":"C++黑马程序员---二、结构体","slug":"C++黑马程序员/C++黑马程序员---结构体","date":"2022-08-06T09:00:00.000Z","updated":"2022-08-06T09:16:13.304Z","comments":true,"path":"posts/6839b2d1.html","link":"","permalink":"https://cotocode.github.io/posts/6839b2d1.html","excerpt":"","text":"语法： struct 结构体名{ 结构体成员列表 }; 2.1 创建学生数据类型struct Student{ string name; //姓名 int age; //年龄 int score; //分数 }; 2.2 通过学生类型创建具体学生struct Student S1; //Student S1 也可 S1.name = \"张三\"; S1.age = 18; S1.score = 100; struct Student S2 = {\"李四\",19,80}; //定义结构体时顺便创建结构变量 struct Student{ string name; //姓名 int age; //年龄 int score; //分数 }S3; //顺便创建结构体变量，S3就是结构体变量 S3.name = \"张三\"; S3.age = 18; S3.score = 100; 2.3 结构体数组语法： struct 结构体名 数组名{元素个数}={{},{},...{}} //1.定义结构体 struct Student{ string name; //姓名 int age; //年龄 int score; //分数 }; int main(){ //2.创建结构体数组 struct Student stuArray[3] = { {\"张三\",18,100}, {\"李四\",28,99}, {\"王五\",38,166}, }; //3.给结构体数组中的元素赋值 stuArray[2].name = \"赵六\"; //4.遍历结构体数组 for(int i = 0 ; i &lt; 3 ; i++) { cout&lt;&lt;\"姓名：\"&lt;&lt;stuArray[i].name &lt;&lt;\"年龄：\"&lt;&lt;stuArray[i].age &lt;&lt;\"成绩：\"&lt;&lt;stuArray[i].score&lt;&lt;endl; } } 2.4 结构体指针利用操作符-&gt;可以通过结构体指针访问结构体属性 //1.定义结构体 struct Student{ string name; //姓名 int age; //年龄 int score; //分数 }; int main(){ //1.创建学生结构体变量 struct Student s = {\"张三\",18,100}; //struct可省略 //2.通过指针指向结构体变量 struct Student * p = &amp;s; //struct可省略 //3.通过指针访问结构体变量中的数据 cout&lt;&lt;\"姓名：\"&lt;&lt; p-&gt;name &lt;&lt;\"年龄：\"&lt;&lt; p-&gt;age &lt;&lt;\"成绩：\"&lt;&lt; p-&gt;score; } 2.5 结构体嵌套结构体//学生结构体 struct student { string name; int age; int score; }; //老师结构体 struct teacher { int id; string name; int age; struct student stu; //辅导的学生 }; int main() { teacher t; t.age = 50; t.id = 10000; t.name = \"老王\"; t.stu.name = \"小王\"; t.stu.age = 18; t.stu.score = 100; cout &lt;&lt; \"老师姓名:\" &lt;&lt; t.name&lt;&lt;endl &lt;&lt; \"学生姓名:\" &lt;&lt; t.stu.name&lt;&lt;endl; system(\"pause\"); return 0; } 2.6 结构体做函数参数//学生结构体 struct student { string name; int age; int score; }; void printstudent1(struct student s)// 值传递 { cout &lt;&lt; \"子函数1中 姓名：\" &lt;&lt; s.name &lt;&lt; endl; } void printstudent2(struct student* p)//地址传递 { cout &lt;&lt; \"子函数2中 姓名：\" &lt;&lt; p-&gt;name &lt;&lt; endl; } int main() { student s; s.name = \"张三\"; s.age = 20; s.score = 85; printstudent1(s); printstudent2(&amp;s); return 0; } 2.7 结构体中const使用void print(const student *p ) //p的值无法被修改，类似实参形参，不过指针只传递地址，参数要传输大量数据，节省了空间.加入const之后一旦有修改操作就会报错","categories":[{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"}],"author":"Co2"},{"title":"leetcode-347. 前 K 个高频元素","slug":"leetcode/leetcode-347. 前 K 个高频元素","date":"2022-08-06T08:00:00.000Z","updated":"2022-09-18T07:33:22.588Z","comments":true,"path":"posts/a6b57153.html","link":"","permalink":"https://cotocode.github.io/posts/a6b57153.html","excerpt":"","text":"本题地址 leetcode-347. 前 K 个高频元素 题目描述： 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 1 &lt;= nums.length &lt;= 10^5 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。 示例： 输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2] 输入: nums = [1], k = 1输出: [1] 题解： 将数组中所有的元素以及这个元素出现的次数记录在一个map中。自定义优先队列的比较方式，将出现次数最少的放在队头，队列中存储k个元素，超过k个元素时，就将队头出队，最后队列中k个元素就是要找的出现频率前k高的元素。基础知识—优先队列。 for(auto a:b)中b为一个容器，效果是利用a遍历并获得b容器中的每一个值，但是a无法影响到b容器中的元素。for(auto &amp;a:b)中加了引用符号，可以对容器中的内容进行赋值，即可通过对a赋值来做到容器b的内容填充。 class Solution { public: vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) { //1.map记录元素出现的次数 unordered_map&lt;int,int&gt; map;//两个int分别是元素和出现的次数 for(auto c:nums){ map[c]++; } //2.利用优先队列，将出现次数排序 //自定义优先队列的比较方式，小顶堆 struct myComparison{ bool operator()(pair&lt;int,int&gt;&amp;p1,pair&lt;int,int&gt;&amp;p2){ return p1.second&gt;p2.second;//小顶堆是大于号 } }; //创建优先队列 priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,myComparison&gt; q; //遍历map中的元素 //1.管他是啥，先入队列，队列会自己排序将他放在合适的位置 //2.若队列元素个数超过k，则将栈顶元素出栈（栈顶元素一定是最小的那个） for(auto&amp; a:map){ q.push(a); if(q.size()&gt;k){ q.pop(); } } //将结果导出 vector&lt;int&gt;res; while(!q.empty()){ res.emplace_back(q.top().first); q.pop(); } return res; } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"}],"author":"Co2"},{"title":"优先队列","slug":"数据结构/优先队列","date":"2022-08-06T08:00:00.000Z","updated":"2022-09-18T07:34:15.506Z","comments":true,"path":"posts/cf8ab80f.html","link":"","permalink":"https://cotocode.github.io/posts/cf8ab80f.html","excerpt":"","text":"1.定义：priority_queue&lt;Type, Container, Functional&gt;; Type是要存放的数据类型Container是实现底层堆的容器，必须是数组实现的容器，如vector、dequeFunctional是比较方式/比较函数/优先级 priority_queue&lt;Type&gt;; 此时默认的Container是vector，默认的Functional是大顶堆less 2.示例：//小顶堆 priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //大顶堆 priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q; //默认大顶堆 priority_queue &lt;int&gt; q; //pair priority_queue&lt;pair&lt;int, int&gt; &gt; a; pair&lt;int, int&gt; b(1, 2); pair&lt;int, int&gt; c(1, 3); pair&lt;int, int&gt; d(2, 5); a.push(d); a.push(c); a.push(b); while (!a.empty()) { cout &lt;&lt; a.top().first &lt;&lt; ' ' &lt;&lt; a.top().second &lt;&lt; '\\n'; a.pop(); } //输出结果为： 2 5 1 3 1 2 3.常用函数： top()pop()push()emplace()empty()size() 4.自定义比较方式：当数据类型并不是基本数据类型，而是自定义的数据类型时，就不能用greater或less的比较方式了，而是需要自定义比较方式在此假设数据类型是自定义的水果： struct fruit { string name; int price; }; 有两种自定义比较方式的方法： 1.重载运算符重载”&lt;” 若希望水果价格高为优先级高 //大顶堆 struct fruit { string name; int price; friend bool operator &lt; (fruit f1,fruit f2) { return f1.peice &lt; f2.price; } }; 若希望水果价格低为优先级高 //小顶堆 struct fruit { string name; int price; friend bool operator &lt; (fruit f1,fruit f2) { return f1.peice &gt; f2.price; //此处是&gt; } }; 2.仿函数若希望水果价格高为优先级高 //大顶堆 struct myComparison { bool operator () (fruit f1,fruit f2) { return f1.price &lt; f2.price; } }; //此时优先队列的定义应该如下 priority_queue&lt;fruit,vector&lt;fruit&gt;,myComparison&gt; q;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"Co2"},{"title":"leetcode-215. 数组中的第K个最大元素","slug":"leetcode/leetcode-215. 数组中的第K个最大元素","date":"2022-08-03T13:00:00.000Z","updated":"2022-09-18T07:32:46.750Z","comments":true,"path":"posts/9a31e8f5.html","link":"","permalink":"https://cotocode.github.io/posts/9a31e8f5.html","excerpt":"","text":"本题地址：leetcode-215. 数组中的第K个最大元素 题目描述： 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。1 &lt;= k &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^4 示例： 输入: [3,2,1,5,6,4], k = 2输出: 5输入: [3,2,3,1,2,4,5,5,6], k = 4输出: 4 题解： 可以构造大根堆，第k个输出的值则为第k大的元素。 class Solution { public: void maxHeapify(vector&lt;int&gt;&amp; a, int i, int heapSize) { int l = i * 2 + 1, r = i * 2 + 2, largest = i; if (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) largest = l; if (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) largest = r; if (largest != i) { swap(a[i], a[largest]); maxHeapify(a, largest, heapSize); } } void buildMaxHeap(vector&lt;int&gt;&amp; a, int heapSize) { for (int i = heapSize / 2; i &gt;= 0; --i) maxHeapify(a, i, heapSize); } int findKthLargest(vector&lt;int&gt;&amp; nums, int k) { int heapSize = nums.size(); buildMaxHeap(nums, heapSize); for (int i = nums.size() - 1; i &gt;= nums.size() - k + 1; --i) { swap(nums[0], nums[i]); --heapSize; maxHeapify(nums, 0, heapSize); } return nums[0]; } };","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"}],"author":"Co2"},{"title":"MarkDown基本语法","slug":"MarkDown语法","date":"2022-08-02T14:00:00.000Z","updated":"2022-09-18T07:33:47.210Z","comments":true,"path":"posts/4a098467.html","link":"","permalink":"https://cotocode.github.io/posts/4a098467.html","excerpt":"","text":"一、标题要创建标题，请在单词或短语前面添加井号 (#) 。# 的数量代表了标题的级别。注：在#后跟个空格再写文字。 二、段落要创建段落，使用空白行将一行或多行文本进行分隔。 三、强调1.粗体要加粗的文字左右分别用两个*号包起来 2.斜体要倾斜的文字左右分别用一个*号包起来 3.粗体和斜体要倾斜和加粗的文字左右分别用三个*号包起来 4.删除线要加删除线的文字左右分别用两个~~号包起来 **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~ 四、引用要创建块引用，在段落前添加一个 &gt; 符号。块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。 五、列表1.有序列表要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 2.无序列表要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。 在列表中嵌套其他元素： 段落 引用块 代码块 图片 列表 六、代码单行代码：代码之间分别用一个反引号包起来 `代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 (```) 代码... 代码... 代码... (```) 七、分隔线要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。为了兼容性，请在分隔线的前后均添加空白行。 Try to put a blank line before --- and after a horizontal rule. Try to put a blank line before and after a horizontal rule. 八、链接链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。 超链接Markdown语法代码：[超链接显示名](超链接地址 \"超链接title\") 这是一个链接 [Markdown语法](https://markdown.com.cn \"超链接title\")。 这是一个链接 Markdown语法。 使用尖括号可以很方便地把URL或者email地址变成可点击的链接。 &lt;https://markdown.com.cn&gt; &lt;fake@example.com&gt; https://markdown.com.cnfake@example.com 九、图片要添加图像，请使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 插入图片Markdown语法代码： ![图片alt](图片链接 \"图片title\") ![这是图片](/assets/img/philly-magic-garden.jpg \"Magic Gardens\") 十、表格语法： 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 十一、流程图```flow st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp;``` st=&gt;start: 开始 op=&gt;operation: My Operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp;``` # 十二、转义字符 要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \\ 。 可做转义的字符： 以下列出的字符都可以通过使用反斜杠字符从而达到转义目的。 \\ ` * _ { } [ ] ( ) # + - . ! |","categories":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://cotocode.github.io/categories/MarkDown/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://cotocode.github.io/tags/MarkDown/"}],"author":"Co2"}],"categories":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/categories/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://cotocode.github.io/categories/%E5%89%91%E6%8C%87Offer/"},{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/categories/leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++黑马程序员","slug":"C-黑马程序员","permalink":"https://cotocode.github.io/categories/C-%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://cotocode.github.io/categories/MarkDown/"}],"tags":[{"name":"代码随想录","slug":"代码随想录","permalink":"https://cotocode.github.io/tags/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"},{"name":"剑指Offer","slug":"剑指Offer","permalink":"https://cotocode.github.io/tags/%E5%89%91%E6%8C%87Offer/"},{"name":"leetcode","slug":"leetcode","permalink":"https://cotocode.github.io/tags/leetcode/"},{"name":"数据结构","slug":"数据结构","permalink":"https://cotocode.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"https://cotocode.github.io/tags/C/"},{"name":"笔记","slug":"笔记","permalink":"https://cotocode.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://cotocode.github.io/tags/MarkDown/"}]}